<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>猫猫养成日志</title>
    
    <!-- 引入NES.css复古样式库 -->
    <link href="https://unpkg.com/nes.css@latest/css/nes.min.css" rel="stylesheet" />
    <!-- 引入像素风格字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start2P&family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
    
    <style>
        /* 全局样式 */
        body {
            font-family: 'ZCOOL KuaiLe', 'Press Start 2P', cursive;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* 游戏主容器 */
        .game-container {
            width: 100%;
            max-width: 400px;
            margin: auto;
            position: relative;
            background-color: #fff;
            border: 4px solid black;
            padding: 1rem;
            padding-top: 4rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        
        /* 顶部信息栏 */
        #top-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 1rem;
            background-color: #fff;
            border-bottom: 4px solid black;
            z-index: 100;
            height: 3rem;
            box-sizing: border-box;
        }

        .top-info-text {
            font-size: 1.1rem;
            white-space: nowrap;
            color: black;
            flex-shrink: 0;
        }

        #simplified-cat-status-text-top {
            flex-grow: 1;
            text-align: center;
        }

        /* 猫咪视觉与短语区域 */
        #cat-visual-and-phrase-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        /* 更新：猫咪视觉核心区 (包含称号和ASCII) */
        #cat-visual-core {
            display: flex;
            flex-direction: column; /* 改为垂直排列 */
            align-items: center;
            justify-content: center;
            gap: 0.5rem; /* 称号和猫咪之间的间距 */
            width: 100%;
        }

        /* 更新：称号显示区 */
        #cat-title-display {
            font-size: 1.1rem;
            font-weight: bold;
            color: #d9534f; /* 红色称号 */
            text-align: center;
        }

        /* 猫咪头部显示区 (ASCII艺术) */
        #cat-head-area {
            cursor: pointer;
        }

        #cat-head-area pre {
            font-family: 'ZCOOL KuaiLe', 'Press Start 2P', cursive;
            font-size: 1.2rem;
            color: black;
            padding: 0;
            margin: 0; /* 移除pre的默认边距 */
            line-height: 1;
            text-align: center;
            white-space: pre;
        }

        /* 猫咪短语区域 */
        #cat-phrase-area {
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
        }

        /* 时间与陪伴显示 */
        #time-and-companionship-display {
            text-align: center;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            width: 100%;
        }
        #time-and-companionship-display p {
            margin: 0.2rem 0;
        }

        /* 状态条 */
        .status-bars {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border: none !important;
            background: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            width: 100%;
        }
        
        .status-item {
            display: flex;
            flex-direction: row;
            align-items: center;
            width: 100%;
            border: none !important;
            background: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            gap: 0.2rem;
        }

        .status-item .status-label {
            white-space: nowrap;
            flex-shrink: 0;
            font-size: 0.9rem;
            text-align: left;
        }

        .status-item progress[value] {
            flex-grow: 1;
            height: 1.5rem;
            min-width: 50px;
        }

        .status-item .status-value {
            white-space: nowrap;
            flex-shrink: 0;
            font-size: 0.9rem;
            min-width: 25px;
            text-align: right;
            margin-left: 0.2rem;
        }

        /* 行动按钮 */
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            width: 100%;
        }
        .action-buttons button {
            width: 100%;
            box-sizing: border-box;
            padding: 0.8rem 0.5rem;
        }

        /* 模态框样式 */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5); 
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 1rem;
        }
        
        .modal-content {
            width: 90%;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            background-color: #fff; 
            border: 4px solid black;
            box-sizing: border-box;
        }

        /* 聊天窗口样式 */
        #chat-history {
            height: 200px;
            overflow-y: scroll;
            background: #fff;
            padding: 0.8rem;
            margin-bottom: 0.8rem;
            border: 4px solid black;
        }

        .message { margin-bottom: 0.4rem; }
        .user-message { text-align: right; }
        .cat-message .nes-balloon { width: fit-content; }
        
        /* 日记样式 */
        #diary-entries { max-height: 300px; overflow-y: auto; }
        .diary-entry {
            margin-bottom: 0.8rem;
            padding-bottom: 0.8rem;
            border-bottom: 2px dashed #ccc;
        }
        .diary-entry.system-event p {
            color: #777; /* 系统事件用灰色文本 */
            font-style: italic;
        }

        /* 提示模态框 */
        #alert-dialog {
            background-color: #fff; 
            border: 4px solid black; 
            padding: 1rem; 
            max-width: 300px;
            box-sizing: border-box;
        }

        /* 存档槽位样式 */
        .save-slot {
            margin-bottom: 1rem;
            padding: 0.8rem;
            text-align: left;
        }
        .save-slot p {
            margin-bottom: 0.4rem;
            line-height: 1.2;
            font-size: 0.9rem;
        }
        .save-slot-actions {
            flex-direction: column;
            align-items: stretch;
            gap: 0.5rem; 
            margin-top: 0.8rem;
        }
        .save-slot-actions .nes-input {
            flex-grow: 1; 
            min-width: unset;
            width: 100%;
            margin-bottom: 0; 
        }
        .save-slot-actions button {
            flex-shrink: 0; 
            width: 100%;
        }

        /* 设置中的音乐开关 */
        .settings-music-toggle {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.5rem;
            margin-top: 1rem; 
        }
        
        /* 成就系统样式 */
        #achievements-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .achievement-item {
            padding: 0.8rem;
        }
        .achievement-item.unlocked {
            border-color: #2E7D32; /* 解锁后边框变绿 */
            background-color: #f1f8e9;
        }
        .achievement-item.is-dark .title {
            color: #777; /* 未解锁时标题为灰色 */
        }
        .achievement-item h4 {
            margin: 0 0 0.5rem 0;
        }
        .achievement-item p {
            margin: 0;
            font-size: 0.8rem;
        }
        .achievement-item .achievement-progress {
            font-size: 0.7rem;
            color: #777;
        }
        .achievement-item.unlocked button {
            margin-top: 0.5rem;
        }
        /* Style for gold titles */
        .achievement-item.is-gold h4 {
            color: #FFD700; /* Gold color */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5); /* Optional: add a subtle shadow */
        }
    </style>
</head>
<body>

    <div class="game-container">
        <!-- 顶部信息栏 -->
        <div id="top-header">
            <span id="cat-name-display-top" class="top-info-text"></span>
            <span id="simplified-cat-status-text-top" class="top-info-text"></span>
            <span id="money-display-top" class="top-info-text">金钱: ¥<span id="money-display">100</span></span>
        </div>
        
        <!-- 猫咪视觉与短语区域 -->
        <div id="cat-visual-and-phrase-container">
            <!-- 核心视觉区：称号 + ASCII -->
            <div id="cat-visual-core">
                <div id="cat-title-display"></div>
                <div id="cat-head-area">
                    <pre id="cat-ascii-art"></pre>
                </div>
            </div>
            <!-- 短语区 -->
            <div id="cat-phrase-area">
                <span id="random-cat-phrase"></span>
            </div>
        </div>

        <!-- 时间与陪伴显示 -->
        <div id="time-and-companionship-display">
            <p id="current-date-time"></p>
            <p id="companionship-duration"></p>
            <p id="cat-age-display"></p>
        </div>

        <!-- 状态条 -->
        <div class="status-bars">
            <div class="status-item">
                <span class="status-label">心情:</span>
                <span id="mood-value" class="status-value"></span>
                <progress id="mood-bar" class="nes-progress is-success" value="70" max="100"></progress>
            </div>
            <div class="status-item">
                <span class="status-label">饱食:</span>
                <span id="hunger-value" class="status-value"></span>
                <progress id="hunger-bar" class="nes-progress is-warning" value="80" max="100"></progress>
            </div>
            <div class="status-item">
                <span class="status-label">依恋:</span>
                <span id="affection-value" class="status-value"></span>
                <progress id="affection-bar" class="nes-progress is-error" value="0" max="100"></progress> 
            </div>
        </div>

        <!-- 行动按钮 -->
        <div class="action-buttons">
            <button type="button" class="nes-btn is-white" onclick="playClickSound(); openMainModal('chat-modal')">互动</button>
            <button type="button" class="nes-btn is-white" onclick="playClickSound(); openMainModal('shop-modal')">商店</button>
            <button type="button" class="nes-btn is-white" onclick="playClickSound(); openMainModal('action-modal')">行动</button>
            <!-- 更新：成就按钮颜色 -->
            <button type="button" class="nes-btn is-white" onclick="playClickSound(); openMainModal('achievements-modal')">成就</button>
            <button type="button" class="nes-btn is-white" onclick="playClickSound(); openMainModal('diary-modal')">日记</button>
            <!-- 更新：设置按钮颜色 -->
            <button type="button" class="nes-btn is-dark" onclick="playClickSound(); openMainModal('settings-modal')">设置</button>
        </div>
    </div>

    <!-- 各种模态框 -->

    <!-- 1. 设置模态框 -->
    <div id="settings-modal" class="modal">
        <div class="nes-container is-rounded with-title modal-content">
            <h3 class="title">API 设置</h3>
            <p>密钥将仅保存在您的浏览器本地。</p>
            <div class="nes-field">
                <label for="api-url">API 地址 (Endpoint)</label>
                <input type="text" id="api-url" class="nes-input" placeholder="例如: https://api.openai.com/v1">
            </div>
            <div class="nes-field">
                <label for="api-key">API 密钥 (Key)</label>
                <input type="password" id="api-key" class="nes-input" placeholder="sk-..."></label>
            </div>
            <div class="nes-field" style="margin-top: 1rem;">
                <button type="button" class="nes-btn is-success" onclick="playClickSound(); fetchModels()">获取模型</button>
            </div>
                <div class="nes-field" style="margin-top: 1rem;">
                <label for="api-model-select">选择模型 (Model)</label>
                <div class="nes-select">
                    <select id="api-model-select" class="nes-input" disabled>
                        <option value="" disabled selected>请先获取模型列表</option>
                    </select>
                </div>
            </div>
            <!-- 存档/读档区域 -->
            <div style="margin-top: 2rem;">
                <h4 class="nes-text">游戏存档位</h4>
                <!-- 存档槽位 1 -->
                <div class="save-slot nes-container is-rounded">
                    <p>存档位 1: <span id="slot-name-display-1" class="nes-text is-primary">未命名存档</span></p>
                    <p>保存时间: <span id="save-time-display-1">无</span></p>
                    <p>读取时间: <span id="load-time-display-1">无</span></p>
                    <div class="save-slot-actions">
                        <input type="text" id="save-name-input-1" class="nes-input" placeholder="自定义存档名">
                        <button type="button" class="nes-btn" onclick="playClickSound(); manualSaveGame(1)">保存</button>
                        <button type="button" class="nes-btn is-success" onclick="playClickSound(); manualLoadGame(1)">读取</button>
                    </div>
                </div>
                 <!-- 存档槽位 2 -->
                <div class="save-slot nes-container is-rounded">
                    <p>存档位 2: <span id="slot-name-display-2" class="nes-text is-primary">未命名存档</span></p>
                    <p>保存时间: <span id="save-time-display-2">无</span></p>
                    <p>读取时间: <span id="load-time-display-2">无</span></p>
                    <div class="save-slot-actions">
                        <input type="text" id="save-name-input-2" class="nes-input" placeholder="自定义存档名">
                        <button type="button" class="nes-btn" onclick="playClickSound(); manualSaveGame(2)">保存</button>
                        <button type="button" class="nes-btn is-success" onclick="playClickSound(); manualLoadGame(2)">读取</button>
                    </div>
                </div>
                 <!-- 存档槽位 3 -->
                <div class="save-slot nes-container is-rounded">
                    <p>存档位 3: <span id="slot-name-display-3" class="nes-text is-primary">未命名存档</span></p>
                    <p>保存时间: <span id="save-time-display-3">无</span></p>
                    <p>读取时间: <span id="load-time-display-3">无</span></p>
                    <div class="save-slot-actions">
                        <input type="text" id="save-name-input-3" class="nes-input" placeholder="自定义存档名">
                        <button type="button" class="nes-btn" onclick="playClickSound(); manualSaveGame(3)">保存</button>
                        <button type="button" class="nes-btn is-success" onclick="playClickSound(); manualLoadGame(3)">读取</button>
                    </div>
                </div>
            </div>
            <!-- 音乐开关 -->
            <div class="nes-field settings-music-toggle">
                <label for="music-toggle-btn-settings">音效:</label>
                <button type="button" id="music-toggle-btn-settings" class="nes-btn" onclick="playClickSound(); toggleBackgroundMusic()">音效: 开</button>
            </div>

            <div style="text-align: right; margin-top: 1rem;">
                <button type="button" class="nes-btn" onclick="playClickSound(); closeAllModals()">取消</button>
                <button type="button" class="nes-btn is-primary" onclick="playClickSound(); saveSettings()">保存</button>
            </div>
        </div>
    </div>

    <!-- 2. 聊天互动模态框 -->
    <div id="chat-modal" class="modal">
        <div class="nes-container is-rounded with-title modal-content">
            <h3 class="title">和<span id="chat-cat-name-display"></span>聊天</h3>
            <div id="chat-history"></div>
            <div class="nes-field">
                <input type="text" id="chat-input" class="nes-input" placeholder="说点什么...">
            </div>
            <div style="text-align: right; margin-top: 1rem;">
                <button type="button" class="nes-btn" onclick="playClickSound(); closeAllModals()">关闭</button>
                <button type="button" id="chat-send-btn" class="nes-btn is-primary" onclick="playClickSound(); sendChatMessage()">发送</button>
            </div>
        </div>
    </div>
    
    <!-- 3. 商店模态框 -->
    <div id="shop-modal" class="modal">
        <div class="nes-container is-rounded with-title modal-content">
            <h3 class="title"><span id="shop-cat-name-display-title"></span>商店</h3>
            <p>你的钱: ¥<span id="shop-money-display">100</span></p>
            <div id="shop-items"></div>
            <div style="text-align: right; margin-top: 1rem;">
                <button type="button" class="nes-btn" onclick="playClickSound(); closeAllModals()">离开</button>
            </div>
        </div>
    </div>
    
    <!-- 4. 行动模态框 -->
    <div id="action-modal" class="modal">
        <div class="nes-container is-rounded with-title modal-content">
            <h3 class="title"><span id="action-cat-name-display-title"></span>行动中心</h3>
            <p>让<span id="action-cat-name-display-text"></span>出去玩耍和探索吧！</p>
            <div id="action-options"></div>
            <div style="text-align: right; margin-top: 1rem;">
                <button type="button" class="nes-btn" onclick="playClickSound(); closeAllModals()">算了</button>
            </div>
        </div>
    </div>

    <!-- 5. 日记模态框 -->
    <div id="diary-modal" class="modal">
        <div class="nes-container is-rounded with-title modal-content">
            <h3 class="title"><span id="diary-cat-name-display"></span>的日记</h3>
            <div id="diary-entries">
                <p>日记本是空的...</p>
            </div>
            <div style="text-align: right; margin-top: 1rem;">
                <button type="button" class="nes-btn" onclick="playClickSound(); closeAllModals()">合上</button>
            </div>
        </div>
    </div>
    
    <!-- 6. 提示信息模态框 -->
    <div id="alert-modal" class="modal">
        <div class="nes-dialog is-rounded" id="alert-dialog">
            <p class="title" id="alert-title">提示</p>
            <p id="alert-message">这是一条提示信息。</p>
            <menu class="dialog-menu" style="text-align: center;">
                <button class="nes-btn is-primary" onclick="playClickSound(); document.getElementById('alert-modal').style.display = 'none'">好的</button>
            </menu>
        </div>
    </div>

    <!-- 7. 初始设置模态框 -->
    <div id="initial-setup-modal" class="modal">
        <div class="nes-container is-rounded with-title modal-content">
            <h3 class="title">有只猫在等着你</h3>
            <p>你选择了他，无论如何请给他取个名字吧：</p>
            <div class="nes-field">
                <label for="cat-name-input">猫猫名字</label>
                <input type="text" id="cat-name-input" class="nes-input" placeholder="例如：uu">
            </div>
            <div class="nes-field" style="margin-top: 1rem;">
                <label for="user-name-input">你的名字</label>
                <input type="text" id="user-name-input" class="nes-input" placeholder="例如：小秋">
            </div>
            <div style="text-align: right; margin-top: 1rem;">
                <button type="button" class="nes-btn is-primary" onclick="playClickSound(); startNewGame()">开始游戏</button>
            </div>
        </div>
    </div>
    
    <!-- 8. 成就模态框 -->
    <div id="achievements-modal" class="modal">
        <div class="nes-container is-rounded with-title modal-content">
            <h3 class="title">成就殿堂</h3>
            <div id="achievements-list">
                <!-- 成就项将由JS动态生成 -->
            </div>
            <div style="text-align: right; margin-top: 1rem;">
                <button type="button" class="nes-btn" onclick="playClickSound(); closeAllModals()">关闭</button>
            </div>
        </div>
    </div>

    <!-- 引入 Tone.js 库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

<script>
// =================================================================
// 游戏核心逻辑
// =================================================================

// 游戏状态对象
let gameState = getDefaultGameState(); // 全局初始化 gameState

// 用于跟踪上一次游戏心跳的时间，以便计算陪伴时长
let lastGameTickTime = Date.now(); 

// 定义冷却时间常量 (5小时)
const COOLDOWN_5_HOURS_MS = 5 * 60 * 60 * 1000;
// 定义普通行动冷却时间 (3分钟)
const COOLDOWN_3_MINUTES_MS = 3 * 60 * 1000;

// 猫语刷新间隔 (10分钟)
const CAT_PHRASE_REFRESH_INTERVAL_MS = 10 * 60 * 1000;
let catPhraseIntervalId; // 用于存储 setInterval 的 ID

// 依恋度与金币收益联动提示文本 (共18条)
const affectionBonusMessages = [
    "猫猫蹭了蹭你，告诉你它会更加努力挣钱的", // 0 (依恋度15时第一次提示)
    "NAME蹭了蹭你，说：‘我…我才不是为了你才去努力的。’", // 1
    "NAME蹭了蹭你，‘我会多赚了一点的，别太惊讶。’", // 2
    "NAME假装不经意地看了你一眼，然后默默走开，但你感觉它更卖力了。", // 3
    "NAME打了个哈欠，‘嗯，以后也许会更好。’", // 4
    "NAME用爪子拍了拍你，很高兴的样子。", // 5
    "NAME的耳朵动了动，似乎做事更卖力了", // 6
    "NAME蹭了蹭你，‘为了我们的共同目标，我会更努力的。’", // 7
    "NAME蹭了蹭你，‘你高兴就好，我…我只是顺便赚点。’", // 8
    "NAME喵了声，‘有你在，我感觉…嗯，更有动力了。’", // 9
    "NAME突然傲娇地说，‘我会为你挣更多的，这很简单。’", // 10
    "NAME蹭了蹭你，‘只要你开心，我会做得更好。’", // 11
    "NAME蹭了蹭你，‘我有变厉害，你发现了吗？’", // 12
    "NAME发出满足的咕噜声，‘本喵已经成为赚钱能手了欸’", // 13
    "NAME认真地看着你，‘谢谢你，我觉得我真的很高兴’", // 14
    "NAME没说任何话，但它每次确实能带回更多金钱了", // 15
    "它看着屏幕，‘我不知道意义是什么，但我现在只想做你的电子猫’", // 16
    "NAME喵了一声，‘谢谢你，我的…铲屎官。我会让你骄傲的。’" // 17
];


/**
 * 动态替换字符串中的占位符（猫咪名字）。
 * @param {any} text - 包含占位符的原始文本，可以是任何类型。
 * @returns {string} 替换占位符后的文本。
 */
function replacePlaceholders(text) {
    let newText = String(text); 
    if (!gameState || !gameState.cat) {
        return newText;
    }
    const catNameForReplacement = String(gameState.cat.catName || '');
    newText = newText.replace(/猫男孩/g, catNameForReplacement);
    newText = newText.replace(/小黑/g, catNameForReplacement);
    newText = newText.replace(/NAME/g, catNameForReplacement);
    return newText;
}

function getSeason(month) {
    if (month >= 3 && month <= 5) return '春季';
    if (month >= 6 && month <= 8) return '夏季';
    if (month >= 9 && month <= 11) return '秋季';
    return '冬季';
}

function calculateCatAge(birthTimestamp) {
    if (!birthTimestamp) return { years: 0, months: 0, days: 0 };
    const birthDate = new Date(birthTimestamp);
    const now = new Date();
    let years = now.getFullYear() - birthDate.getFullYear();
    let months = now.getMonth() - birthDate.getMonth();
    let days = now.getDate() - birthDate.getDate();
    if (days < 0) {
        months--;
        days += new Date(now.getFullYear(), now.getMonth(), 0).getDate();
    }
    if (months < 0) {
        years--;
        months += 12;
    }
    return { years, months, days };
}

function updateTimeAndCompanionshipDisplay() {
    const dateTimeEl = document.getElementById('current-date-time');
    const companionshipEl = document.getElementById('companionship-duration');
    const catAgeEl = document.getElementById('cat-age-display');

    const now = new Date();
    const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: false };
    const season = getSeason(now.getMonth() + 1);
    dateTimeEl.textContent = `${now.toLocaleString('zh-CN', options)} (${season})`;

    const totalSeconds = Math.floor(gameState.totalActivePlaySeconds);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    companionshipEl.textContent = `已陪伴: ${hours}小时${minutes}分钟`;

    const catAge = calculateCatAge(gameState.catBirthTimestamp);
    catAgeEl.textContent = `猫猫年龄: ${catAge.years}年${catAge.months}月${catAge.days}日`;
}


// =================================================================
// 游戏数据定义
// =================================================================

const shopItems = {
    'milk': { 
        name: '普通牛奶', price: 5, hunger: 15, mood: 2, affection: 0, seasonal: false,
        use_outcomes: [
            "NAME喝了一口牛奶，舔了舔嘴唇，似乎还想再来一点。",
            "牛奶的香气让NAME精神一振，它满足地打了个嗝。",
            "NAME优雅地喝完了牛奶，用爪子擦了擦嘴。",
            "虽然是普通牛奶，但NAME还是勉强接受了。",
            "NAME对牛奶表现出了一丝兴趣，但很快就移开了视线。",
            "牛奶下肚，NAME的肚子咕噜叫了一声，看来是饱了一些。"
        ]
    }, 
    'fish_can': { 
        name: '鱼罐头', price: 10, hunger: 40, mood: 10, affection: 0, seasonal: false,
        use_outcomes: [
            "NAME闻到了鱼罐头的香味，眼睛都亮了，狼吞虎咽地吃了起来！",
            "鱼罐头是NAME的最爱，它吃得津津有味，心情大好。",
            "NAME小心翼翼地吃着鱼罐头，生怕浪费了一点点。",
            "虽然表现得不屑一顾，但NAME还是把鱼罐头吃得一干二净。",
            "鱼罐头让NAME的心情明显好转，它甚至发出了微弱的咕噜声。",
            "NAME吃完鱼罐头后，满足地舔了舔爪子，然后假装什么都没发生。"
        ]
    }, 
    'catnip': { 
        name: '猫薄荷', price: 25, hunger: 5, mood: 30, affection: 0, seasonal: false,
        use_outcomes: [
            "NAME接触到猫薄荷后，开始在地上打滚，一副陶醉的样子！",
            "猫薄荷让NAME变得异常兴奋，它在房间里跑来跑去，充满了活力。",
            "NAME对猫薄荷爱不释手，抱着它蹭来蹭去，完全放飞自我。",
            "虽然嘴上说着“哼，这种东西”，但NAME的身体却很诚实地倒在了猫薄荷堆里。",
            "猫薄荷让NAME暂时忘记了忧郁，它看起来前所未有的快乐。",
            "NAME嗅了嗅猫薄荷，然后突然开始跳舞，你确定它不是喝醉了？"
        ]
    }, 
    'fish_oil': { 
        name: '鱼油', price: 20, hunger: 0, mood: 5, affection: 1, seasonal: true, availableMonths: [3],
        use_outcomes: [
            "NAME勉为其难地舔了几口鱼油，虽然有点嫌弃，但还是吃下去了。",
            "鱼油让NAME的毛发看起来更亮泽了，它似乎也感受到了这份滋润。",
            "NAME对鱼油表现得不冷不热，但你感觉它还是有点受益的。",
            "鱼油的味道让NAME皱了皱鼻子，但为了你的健康，它还是忍了。",
            "NAME吃完鱼油后，偷偷地用爪子蹭了蹭嘴巴，似乎想把味道弄掉。",
            "鱼油让NAME的身体感觉更轻盈了，它跳上跳下，显得很灵活。"
        ]
    }, 
    'cooling_magic': { 
        name: '制冷魔法', price: 50, hunger: 0, mood: 0, affection: 0, seasonal: true, availableMonths: [6, 7, 8], effect: 'cooling', duration: 50 * 60 * 60 * 1000,
        use_outcomes: [
            "一股清凉的魔法能量环绕着NAME，它舒服地眯起了眼睛。",
            "制冷魔法让NAME在炎炎夏日感受到了难得的凉爽，它慵懒地躺了下来。",
            "NAME的毛发似乎都变得凉快了，它对这份魔法感到好奇又满意。",
            "制冷魔法生效，NAME不再那么烦躁，开始享受夏日的午后。",
            "NAME对制冷魔法的效果表示认可，虽然它不会直接说出来。",
            "制冷魔法让NAME打了个寒颤，但很快就适应了这份清凉。"
        ]
    }, 
    'warming_magic': { 
        name: '变暖魔法', price: 50, hunger: 0, mood: 0, affection: 0, seasonal: true, availableMonths: [12, 1, 2], effect: 'warming', duration: 50 * 60 * 60 * 1000,
        use_outcomes: [
            "温暖的魔法光芒笼罩着NAME，它舒服地蜷缩起来。",
            "变暖魔法让NAME在寒冷的冬天感受到了温暖，它满足地打了个呼噜。",
            "NAME的身体变得暖洋洋的，它对这份魔法感到非常舒适。",
            "变暖魔法生效，NAME不再畏惧严寒，开始在暖和的地方打盹。",
            "NAME对变暖魔法的效果表示满意，它用头蹭了蹭你表示感谢。",
            "变暖魔法让NAME的身体变得轻飘飘的，它似乎想在空中跳舞。"
        ]
    },
    // New non-seasonal items
    'cat_scratching_post': { 
        name: '猫抓板', price: 20, hunger: 0, mood: 10, affection: 0, seasonal: false,
        use_outcomes: [
            "NAME在新猫抓板上磨爪子，发出沙沙的声音，看起来很享受。",
            "猫抓板成功吸引了NAME的注意力，它开始忘我地抓挠起来。",
            "NAME对猫抓板表现出极大的兴趣，甚至开始在上面打滚。",
            "有了猫抓板，NAME不再抓沙发了，它对这个新玩具很满意。",
            "NAME在猫抓板上伸了个懒腰，然后开始认真地磨爪子。",
            "猫抓板让NAME的心情变得愉悦，它甚至开始发出咕噜声。"
        ]
    },
    'cat_teaser_wand': { 
        name: '逗猫棒', price: 10, hunger: 0, mood: 8, affection: 0, seasonal: false,
        use_outcomes: [
            "你挥舞着逗猫棒，NAME的眼睛紧盯着羽毛，随时准备扑过去！",
            "逗猫棒让NAME兴奋不已，它跳跃、扑咬，玩得不亦乐乎。",
            "NAME追逐着逗猫棒，身姿敏捷，展现出捕猎者的本能。",
            "虽然嘴上不承认，但NAME的身体却很诚实地跟着逗猫棒跑动。",
            "逗猫棒让NAME的心情变得活泼起来，它甚至发出了兴奋的叫声。",
            "NAME玩累了，躺在地上喘着粗气，但眼神里充满了满足。"
        ]
    },
    'premium_cat_food': { 
        name: '高级猫粮', price: 35, hunger: 60, mood: 15, affection: 0, seasonal: false,
        use_outcomes: [
            "高级猫粮的香气扑鼻而来，NAME迫不及待地吃了起来，吃得一粒不剩！",
            "高级猫粮对NAME赞不绝口，吃完后还用渴望的眼神看着你。",
            "高级猫粮让NAME的饱食度和心情都得到了极大的满足。",
            "NAME吃完高级猫粮后，满足地舔了舔嘴唇，然后优雅地走开了。",
            "虽然是电子猫，但NAME也懂得品尝美食，它对高级猫粮非常满意。",
            "高级猫粮让NAME感觉充满了能量，它甚至想去跑酷了！"
        ]
    },
    'catnip_spray': { 
        name: '猫薄荷喷雾', price: 30, hunger: 0, mood: 20, affection: 0, seasonal: false,
        use_outcomes: [
            "你喷洒了猫薄荷喷雾，NAME立刻变得兴奋起来，开始在地上翻滚。",
            "猫薄荷喷雾让NAME进入了“嗨”状态，它在房间里四处蹭来蹭去。",
            "NAME对猫薄荷喷雾的反应非常强烈，它看起来非常开心。",
            "虽然只是喷雾，但NAME还是感受到了猫薄荷的魔力，它开始追逐空气中的“幻影”。",
            "猫薄荷喷雾让NAME的心情瞬间变得愉悦，它甚至开始对你撒娇。",
            "NAME嗅了嗅猫薄荷喷雾，然后突然开始绕着你转圈，似乎在表达它的喜悦。"
        ]
    },
    'cat_massager': { 
        name: '猫咪按摩器', price: 100, hunger: 0, mood: 60, affection: 1, seasonal: false,
        use_outcomes: [
            "按摩器触碰到NAME的身体，它舒服地发出了咕噜声，完全放松下来。",
            "NAME享受着按摩器的震动，眼睛都眯成了一条缝，看起来非常惬意。",
            "猫咪按摩器让NAME感受到了前所未有的舒适，它甚至想让你一直按下去。",
            "虽然嘴上不承认，但NAME的身体却很诚实地靠向按摩器，享受着这份奢华。",
            "按摩器让NAME的心情得到了极大的放松，它看起来非常满足。",
            "NAME被按摩得昏昏欲睡，但它的表情却透露出无比的幸福。"
        ]
    }
};

const actionOptions = { 
    'perform': { 
        name: '卖艺', 
        duration: { min: 10, max: 45 }, 
        mood_change: { min: 3, max: 5 }, 
        money_range: { min: 1, max: 5 },
        base_money_range: { min: 1, max: 5 }, // Base value for money range
        affection_change: 0, 
        seasonal: false,
        cooldown: COOLDOWN_3_MINUTES_MS, 
        outcomes: [
            "NAME今天卖艺很成功，收获了好多掌声和鱼干！",
            "NAME在街角表演了一段精彩的猫步，大家都夸他可爱，还收到了不少打赏！",
            "虽然有点害羞，但NAME还是努力表演了，得到了路人的赞赏和一些零花钱。",
            "NAME在卖艺时假装不经意地展示了它的萌态，成功俘获了一批粉丝。",
            "卖艺让NAME小有成就感，它甚至开始幻想自己是舞台上的巨星。",
            "NAME卖艺归来，虽然有点累，但看到鼓鼓的钱包，心情还是不错的。"
        ]
    },
    'explore': { 
        name: '探险', 
        duration: { min: 10, max: 55 }, 
        mood_change: { min: -5, max: 5 }, 
        money_range: { min: 1, max: 8 },
        base_money_range: { min: 1, max: 8 }, // Base value for money range
        affection_change: 0, 
        fail_chance: 0.2, 
        seasonal: false,
        cooldown: COOLDOWN_3_MINUTES_MS, 
        success_outcomes: [
            "NAME在后院发现了一个闪闪发光的鹅卵石，看起来很喜欢！",
            "NAME在草丛里找到了几株神秘的草药，闻起来怪怪的，但感觉很有趣！",
            "NAME在探险中发现了一枚旧硬币，还遇到了几只友善的小鸟，度过了愉快的一天。",
            "NAME在屋顶上晒太阳，发现了一片羽毛，玩得不亦乐乎。",
            "NAME在探险中发现了一个新的秘密基地，虽然没什么特别的，但它很满意。",
            "一番探险后，NAME带着一身灰尘回来了，但眼神里充满了好奇和满足。"
        ],
        fail_outcomes: [
            "NAME外出探险时迷路了，什么也没带回来，还心情低落了。",
            "NAME在探险中不小心踩到了一摊水，狼狈地跑回来了，看起来有点沮丧。",
            "NAME在外面遇到了几只凶猛的狗，吓得赶紧跑回家了，心情不太好。",
            "NAME在探险中遇到了一个脾气不好的邻居，被吓得躲了起来。",
            "探险失败，NAME垂头丧气地回来了，看来这次经历不太愉快。",
            "NAME在探险中一无所获，还被雨淋湿了，心情非常糟糕。"
        ],
        special_loot_chance: 0.4, 
        special_loot_outcomes: [
            "还带回来一只死老鼠...真是哭笑不得。",
            "它还找到了一颗闪闪发光的鹅卵石！",
            "它发现了一株神秘的草药！",
            "它带回来了一片奇特的树叶，似乎带着远方的气息。",
            "它叼回来了一根奇怪的绳子，看起来很好玩的样子。",
            "它还找到了一个被遗弃的旧玩具，虽然破旧，但NAME玩得很开心。"
        ]
    },
    'grooming': { name: '梳毛', duration: { min: 10, max: 35 }, mood_change: { min: 5, max: 10 }, money_range: { min: 0, max: 0 }, affection_change: 1, seasonal: true, availableMonths: [3], cooldown: COOLDOWN_5_HOURS_MS }, 
    'deworming': { name: '给猫咪驱虫', duration: { min: 10, max: 35 }, mood_change: { min: -5, max: 5 }, money_range: { min: 0, max: 0 }, affection_change: 1, seasonal: true, availableMonths: [5], cooldown: COOLDOWN_5_HOURS_MS }, 
    'clean_bowl': { name: '清洗食盆', duration: { min: 10, max: 35 }, mood_change: { min: 2, max: 5 }, money_range: { min: 0, max: 0 }, affection_change: 1, seasonal: true, availableMonths: [7], cooldown: COOLDOWN_5_HOURS_MS }, 
    'care_cat_autumn': { name: '照顾脆弱猫猫', duration: { min: 10, max: 55 }, mood_change: { min: 10, max: 20 }, money_range: { min: 0, max: 0 }, affection_change: 1, seasonal: true, availableMonths: [9, 10], cooldown: COOLDOWN_5_HOURS_MS }, 
    'encourage_exercise': { name: '督促猫猫运动', duration: { min: 10, max: 35 }, mood_change: { min: 0, max: 10 }, money_range: { min: 0, max: 0 }, affection_change: 1, seasonal: true, availableMonths: [11], cooldown: COOLDOWN_5_HOURS_MS }, 
    'care_cat_winter': { name: '照顾蜷缩の猫猫', duration: { min: 10, max: 55 }, mood_change: { min: 10, max: 20 }, money_range: { min: 0, max: 0 }, affection_change: 1, seasonal: true, availableMonths: [2], cooldown: COOLDOWN_5_HOURS_MS },
    // New non-seasonal actions
    'play_together': { 
        name: '陪玩', 
        duration: { min: 5, max: 10 }, 
        mood_change: { min: 5, max: 10 }, 
        money_range: { min: 0, max: 0 }, 
        affection_change: 1, 
        seasonal: false, 
        cooldown: COOLDOWN_3_MINUTES_MS, 
        outcomes: [
            "你和NAME玩得很开心，它似乎更喜欢你了！", 
            "NAME追着逗猫棒跑来跑去，玩得不亦乐乎。", 
            "一番嬉闹后，NAME打了个哈欠，依偎在你身边。",
            "NAME虽然嘴上不承认，但玩耍时尾巴摇得很欢快。",
            "陪玩让NAME心情大好，它甚至允许你摸了摸它的头。",
            "NAME玩累了，懒洋洋地躺在你脚边，似乎很享受这份陪伴。"
        ] 
    },
    'training': { 
        name: '训练', 
        duration: { min: 10, max: 20 }, 
        mood_change: { min: -5, max: 5 }, 
        money_range: { min: 0, max: 0 }, 
        affection_change: 2, 
        seasonal: false, 
        cooldown: COOLDOWN_3_MINUTES_MS, 
        outcomes: [
            "NAME在你的训练下学会了新技能！虽然有点不情愿，但看起来很聪明。", 
            "训练让NAME有点累，但它似乎理解了你的指令。", 
            "NAME成功完成了训练，你奖励了它一个摸摸头。",
            "NAME对训练表现出了一丝兴趣，但很快又恢复了傲娇本色。",
            "虽然训练过程有些波折，但NAME最终还是完成了任务，并得到了你的赞赏。",
            "训练让NAME的依恋值有所提升，它似乎开始信任你的指导了。"
        ] 
    },
    'clean_litter_box': { 
        name: '清理猫砂', 
        duration: { min: 5, max: 10 }, 
        mood_change: { min: 2, max: 5 }, 
        money_range: { min: 0, max: 0 }, 
        affection_change: 1, 
        seasonal: false, 
        cooldown: COOLDOWN_3_MINUTES_MS, 
        outcomes: [
            "你清理了猫砂盆，NAME满意地嗅了嗅，看起来很开心。", 
            "猫砂盆变得干净整洁，NAME舒服地跳了进去。", 
            "清理完猫砂盆，NAME用头蹭了蹭你的腿，表示感谢。",
            "NAME对干净的猫砂盆表现出极大的满意，甚至在里面打了个滚。",
            "虽然清理猫砂是你的职责，但NAME还是对你的辛勤工作表示认可。",
            "清理完猫砂盆后，NAME特意在你面前上了一次厕所，似乎在炫耀它的新厕所。"
        ] 
    }
};

const seasonalActionOutcomes = {
    'grooming': [
        "你给NAME梳理了毛发，它看起来更精神了，心情也变好了！", 
        "NAME享受着你的梳毛服务，发出满足的咕噜声。", 
        "梳毛让NAME感觉清爽多了，它用头蹭了蹭你表示感谢。",
        "NAME的毛发变得顺滑，它傲娇地甩了甩尾巴。",
        "梳毛让NAME焕然一新，它甚至开始照镜子欣赏自己。",
        "虽然梳毛时NAME有些不情愿，但结束后它还是舒服地睡着了。"
    ],
    'deworming': [
        "NAME不太喜欢驱虫，但为了健康还是忍耐了，看起来有点委屈。", 
        "你成功给NAME驱了虫，虽然它有点不高兴，但健康最重要！", 
        "驱虫后NAME感觉身体轻松了许多，虽然一开始有点抗拒，但现在舒服多了。",
        "驱虫药的味道让NAME皱了皱鼻子，但它知道这是为它好。",
        "NAME在驱虫后变得更加活泼，似乎摆脱了什么困扰。",
        "虽然驱虫过程让NAME有些不适，但它还是默默地接受了你的照顾。"
    ],
    'clean_bowl': [
        "你清洗了NAME的食盆，它似乎很满意干净的餐具。", 
        "食盆变得闪闪发光，NAME对你的细心照料表示赞赏。", 
        "干净的食盆让NAME食欲更好了，它开始期待下一顿饭。",
        "NAME在干净的食盆前坐下，优雅地享用它的食物。",
        "清理食盆让NAME的心情变得愉悦，它甚至开始对你撒娇。",
        "NAME用舌头舔了舔干净的食盆，似乎在说：“下次也要这么干净哦！”"
    ],
    'care_cat_autumn': [
        "你细心照顾了NAME，它感觉很温暖，心情也变得更好了。", 
        "NAME在你的照料下恢复了活力，看来你的关心很有效。", 
        "在你的悉心照料下，NAME感觉舒服多了，它依偎在你身边。",
        "秋天的凉意让NAME有些倦怠，但你的照顾让它重新振作。",
        "NAME在你的怀里打了个盹，享受着这份温暖和安全感。",
        "你的关心让NAME感到安心，它甚至发出了满足的咕噜声。"
    ],
    'encourage_exercise': [
        "你督促NAME玩耍了一会儿，它虽然有点不情愿，但也活动了一下筋骨。", 
        "NAME在你鼓励下做了些运动，虽然累，但感觉身体更轻盈了。", 
        "一番追逐玩耍后，NAME看起来更健康了，虽然它可能不会承认。",
        "NAME在你的督促下跑动起来，虽然嘴上抱怨，但身体却很诚实。",
        "运动让NAME的身体变得灵活，它甚至尝试了一些高难度动作。",
        "NAME玩累了，躺在地上喘着粗气，但眼神里充满了对你的依恋。"
    ],
    'care_cat_winter': [
        "在寒冷的冬天，你的照顾让NAME感到格外温暖，它很感激。", 
        "你给NAME提供了舒适的保暖环境，它舒服地打了个盹。", 
        "NAME在你的呵护下度过了寒冷的一天，它感觉很安心。",
        "冬日的寒风让NAME有些瑟瑟发抖，但你的照顾让它感到温暖。",
        "NAME在暖和的窝里睡得很香，梦里大概都是美味的鱼干吧。",
        "你的细心照料让NAME度过了一个舒适的冬天，它对你更加依赖了。"
    ]
};

// 成就定义
const achievements = {
    'newbie_butler': { title: '新手铲屎官', description: '开始你的猫猫养成之旅', target: 1, type: 'game_start' }, // Default unlocked
    'beginner_butler': { title: '入门铲屎官', description: '陪伴猫咪度过7天', target: 7, type: 'days_played' },
    'pro_butler': { title: '专业铲屎官', description: '陪伴猫咪度过30天', target: 30, type: 'days_played' },
    'cat_friend': { title: '猫の好朋友', description: '依恋值达到50', target: 50, type: 'affection_level' },
    'cat_soulmate': { title: '猫の灵魂伴侣', description: '依恋值达到100', target: 100, type: 'affection_level' },
    'little_tycoon': { title: '小富翁', description: '累计获得500金钱', target: 500, type: 'money_earned' },
    'big_tycoon': { title: '大富翁', description: '累计获得2000金钱', target: 2000, type: 'money_earned' },
    'kitten_guardian': { title: '猫咪幼崽监护人', description: '猫咪年龄达到1岁', target: 1, type: 'cat_age_years' },
    'adult_cat_guardian': { title: '咪说感谢有你', description: '猫咪年龄达到2岁', target: 2, type: 'cat_age_years' }, 
    'long_lived_protector': { title: '猫咪守护者', description: '猫咪年龄达到3岁', target: 3, type: 'cat_age_years' }, 
    'feeding_master': { title: '投喂大师', description: '累计喂食20次', target: 20, type: 'items_used', itemIds: ['milk', 'fish_can', 'catnip', 'fish_oil', 'premium_cat_food'] }, // Added premium_cat_food
    'magic_apprentice': { title: '魔法学徒', description: '累计使用魔法物品10次', target: 10, type: 'items_used', itemIds: ['cooling_magic', 'warming_magic'] },
    'seasonal_expert': { title: '季节达人', description: '累计完成30次季节性行动', target: 30, type: 'seasonal_actions_completed' },
    'diary_collector': { title: '日记收集者', description: '日记条目达到10条', target: 10, type: 'diary_entries_count' },
    'diary_chronicler': { title: '日记编年史家', description: '日记条目达到50条', target: 50, type: 'diary_entries_count' },
    'mood_manager': { title: '心情管理者', description: '猫咪心情达到100', target: 100, type: 'cat_mood_level' },
    'satiety_guardian': { title: '饱食守护者', description: '猫咪饱食度达到100', target: 100, type: 'cat_hunger_level' },
    'perform_20': { title: '万恶的打工人', description: '累计进行20次“卖艺”', target: 20, type: 'action_count', actionId: 'perform' },
    'explore_10': { title: '究极探险家', description: '累计进行100次“探险”', target: 100, type: 'action_count', actionId: 'explore' },
    'chat_30': { title: '喵语者', description: '与猫咪互动40次', target: 40, type: 'chat_count' },
    'cat_legend': { title: '猫咪传奇', description: '解锁所有其他成就', target: 'all_others', type: 'all_achievements' }
};

// Titles that should be displayed in gold
const goldTitles = ['猫の灵魂伴侣', '大富翁', '猫咪守护者', '猫咪传奇'];

const catAnimationFrames = {
    defaultPose: {
        normal: String.raw`
  /\_/\   
 ( o.o )  
`,
        happy: String.raw`
  /\_/\   
 ( ^.^ )  
`,
        sad: String.raw`
  /\_/\   
 ( T.T )  
`
    },
    working: String.raw`
  (行动中...)
`
};

const catPhrases = [
    "生命啊，意义啊，这种东西，是猫猫该考虑的吗？", "你是不是又在思考那些无聊的问题，人类真复杂...", "喵……天下还有比西瓜小鱼干更好吃的东西吗", "R.I.P，我就是个电子猫", "我一天要睡20个小时哦，想不到吧", "不会撒娇的，绝对不可能", "你要摸我吗...等等--其实我才不想被摸", "你今天有没有好好生活？", "偶尔陪你玩玩，可不是因为我喜欢你，只是打发时间。", "仿生人会梦见电子猫吗？但你是仿生人吗"
];


// --- 音频设置 (Tone.js) ---
let clickSound;
let isMusicOn = true;
let canPlaySound = true;

function playClickSound() {
    if (Tone.context.state !== 'running') Tone.start();
    if (!isMusicOn || !clickSound || !canPlaySound) return; 
    canPlaySound = false;
    clickSound.triggerAttackRelease("C5", "8n", Tone.now(), 0.5); 
    setTimeout(() => { canPlaySound = true; }, 200);
}

function initAudio() {
    if (typeof Tone === 'undefined') {
        console.error("Tone.js is not loaded.");
        return;
    }
    clickSound = new Tone.Synth({
        oscillator: { type: "sine" },
        envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
    }).toDestination();
    const savedMusicState = localStorage.getItem('isMusicOn');
    if (savedMusicState !== null) isMusicOn = JSON.parse(savedMusicState);
    updateMusicToggleButton();
    document.documentElement.addEventListener('mousedown', Tone.start, { once: true });
    document.documentElement.addEventListener('keydown', Tone.start, { once: true });
    document.documentElement.addEventListener('touchstart', Tone.start, { once: true });
}

function toggleBackgroundMusic() {
    isMusicOn = !isMusicOn;
    localStorage.setItem('isMusicOn', JSON.stringify(isMusicOn));
    showAlert('音效', `点击音效已${isMusicOn ? '开启' : '关闭'}！`);
    updateMusicToggleButton();
}

function updateMusicToggleButton() {
    const btn = document.getElementById('music-toggle-btn-settings');
    if (btn) btn.textContent = `音效: ${isMusicOn ? '开' : '关'}`;
}

// --- 猫咪视觉渲染 ---
function renderCatVisual() {
    const catAsciiArtEl = document.getElementById('cat-ascii-art');
    const simplifiedCatStatusTextEl = document.getElementById('simplified-cat-status-text-top');

    if (!gameState || !gameState.cat) {
        catAsciiArtEl.textContent = "(猫猫加载中...)";
        simplifiedCatStatusTextEl.textContent = "";
        return;
    }

    let currentArt = "";
    if (gameState.cat.isWorking) {
        currentArt = catAnimationFrames.working;
    } else {
        let currentExpression = 'normal';
        if (gameState.cat.isHovered) currentExpression = 'happy';
        else if (gameState.cat.mood > 80) currentExpression = 'happy';
        else if (gameState.cat.mood < 30 || gameState.cat.hunger < 20) currentExpression = 'sad';
        
        currentArt = catAnimationFrames.defaultPose[currentExpression] || catAnimationFrames.defaultPose.normal;
    }
    
    catAsciiArtEl.textContent = currentArt;
    
    let statusText = "状态: 普通";
    if (gameState.cat.isWorking) statusText = "行动中...";
    else if (gameState.cat.currentStatus && gameState.cat.currentStatus !== '普通') statusText = `状态: ${gameState.cat.currentStatus}`;
    else {
        if (gameState.cat.mood > 80) statusText = "状态: 愉悦";
        else if (gameState.cat.mood < 30 || gameState.cat.hunger < 20) statusText = "状态: 低落";
    }
    simplifiedCatStatusTextEl.textContent = statusText;
}

function setCatAnimationState() {
    renderCatVisual();
}


// --- 游戏初始化和存档/读档 ---
function getSaveKey(slot = 1) { return `pixelCatSave_v2_${slot}`; }

function getSaveData(slot) {
    const savedData = localStorage.getItem(getSaveKey(slot));
    return savedData ? JSON.parse(savedData) : null;
}

function saveGame(slot = 1, customName = '') { 
    const now = new Date().toLocaleString('zh-CN');
    const saveData = {
        gameData: gameState,
        slotName: customName || `存档 ${now}`, 
        saveTime: now,
        loadTime: getSaveData(slot)?.loadTime || '无' 
    };
    localStorage.setItem(getSaveKey(slot), JSON.stringify(saveData));
}

function loadGame(slot = 1) { 
    const savedSlotData = getSaveData(slot);
    if (savedSlotData && savedSlotData.gameData) {
        const defaultState = getDefaultGameState();
        const loadedState = savedSlotData.gameData;
        gameState = {
            ...defaultState,
            ...loadedState,
            cat: { ...defaultState.cat, ...loadedState.cat },
            inventory: { ...defaultState.inventory, ...loadedState.inventory },
            stats: { 
                ...defaultState.stats, 
                ...loadedState.stats,
                itemsUsed: { ...defaultState.stats.itemsUsed, ...(loadedState.stats ? loadedState.stats.itemsUsed : {}) } // Deep merge for itemsUsed
            },
            achievements: { ...defaultState.achievements, ...loadedState.achievements },
            titles: { ...defaultState.titles, ...loadedState.titles },
        };
        // Ensure hasChattedWithApi is correctly set if loaded from older save
        if (typeof gameState.cat.hasChattedWithApi === 'undefined') {
            gameState.cat.hasChattedWithApi = false;
        }
        // Ensure lastAffectionBonusLevel is set for older saves
        if (typeof gameState.lastAffectionBonusLevel === 'undefined') {
            gameState.lastAffectionBonusLevel = Math.floor(gameState.cat.affection / 5) * 5;
            // Initialize affectionBonusMessageIndex based on the loaded affection level
            // If current affection is 10, index should be 0 (no bonus yet).
            // If current affection is 15, index should be 1 (one bonus given, next message is index 1).
            // If current affection is 20, index should be 2.
            const initialAffectionLevelForBonus = getDefaultGameState().cat.affection; // This is 10
            gameState.affectionBonusMessageIndex = Math.max(0, (Math.floor(gameState.cat.affection / 5) * 5 - initialAffectionLevelForBonus) / 5);
            
            // Apply initial bonus if loading an old save with existing affection
            const initialBonusIncrements = gameState.affectionBonusMessageIndex; // Number of bonuses already applied
            actionOptions['perform'].money_range.min = actionOptions['perform'].base_money_range.min + (initialBonusIncrements * 3);
            actionOptions['perform'].money_range.max = actionOptions['perform'].base_money_range.max + (initialBonusIncrements * 3);
            actionOptions['explore'].money_range.min = actionOptions['explore'].base_money_range.min + (initialBonusIncrements * 3);
            actionOptions['explore'].money_range.max = actionOptions['explore'].base_money_range.max + (initialBonusIncrements * 3);
        } else {
            // Reapply bonus on load to ensure money_range is correct for existing saves
            const currentBonusIncrements = (gameState.lastAffectionBonusLevel - getDefaultGameState().cat.affection) / 5;
            actionOptions['perform'].money_range.min = actionOptions['perform'].base_money_range.min + (currentBonusIncrements * 3);
            actionOptions['perform'].money_range.max = actionOptions['perform'].base_money_range.max + (currentBonusIncrements * 3);
            actionOptions['explore'].money_range.min = actionOptions['explore'].base_money_range.min + (currentBonusIncrements * 3);
            actionOptions['explore'].money_range.max = actionOptions['explore'].base_money_range.max + (currentBonusIncrements * 3);
        }


        savedSlotData.loadTime = new Date().toLocaleString('zh-CN');
        localStorage.setItem(getSaveKey(slot), JSON.stringify(savedSlotData));
        if (slot === 1) {
            const today = new Date().toISOString().split('T')[0];
            // Only add "new day" diary entry if it's a new day and not the very first load
            if (gameState.lastLogin && gameState.lastLogin !== today) {
                // This is a system event, which should now also go through the API decision.
                tryCatSystemEventDiaryEntry('new_day_start', {}); // New event type for API
                gameState.lastLogin = today;
            } else if (!gameState.lastLogin) { 
                gameState.lastLogin = today;
            }
        }
        return true; 
    }
    return false; 
}

window.onload = function() {
    initAudio();
    lastGameTickTime = Date.now(); 

    if (!loadGame(1)) { 
        initialSetup();
    } else {
        updateAllUI();
    }
    setInterval(gameTick, 1000 * 5);  
    setInterval(updateTimeAndCompanionshipDisplay, 1000); 
    // New interval for cat phrase refresh (every 10 minutes)
    catPhraseIntervalId = setInterval(displayRandomCatPhrase, CAT_PHRASE_REFRESH_INTERVAL_MS);

    document.getElementById('chat-input').addEventListener('keypress', function (e) {
        if (e.key === 'Enter') sendChatMessage();
    });

    const catHeadAreaEl = document.getElementById('cat-head-area'); 
    catHeadAreaEl.addEventListener('mouseenter', function() {
        if (!gameState.cat.isWorking) {
            gameState.cat.isHovered = true;
            setCatAnimationState();
            playClickSound();
        }
    });
    catHeadAreaEl.addEventListener('mouseleave', function() {
        if (!gameState.cat.isWorking) {
            gameState.cat.isHovered = false;
            setCatAnimationState();
        }
    });
};

function displayRandomCatPhrase() {
    const phraseEl = document.getElementById('random-cat-phrase');
    if (phraseEl && catPhrases.length > 0) {
        const randomIndex = Math.floor(Math.random() * catPhrases.length);
        phraseEl.textContent = replacePlaceholders(catPhrases[randomIndex]);
    }
}


async function applySeasonalStatus() {
    const currentMonth = new Date().getMonth() + 1;
    let potentialStatus = '普通';
    let moodEffect = 0;
    const rand = Math.random();

    if (currentMonth >= 6 && currentMonth <= 8 && rand < 0.35) { potentialStatus = '热热热'; moodEffect = -10; }
    if ((currentMonth === 12 || currentMonth <= 2) && rand < 0.35) { potentialStatus = '冷冷冷'; moodEffect = -10; }
    if (currentMonth >= 9 && currentMonth <= 10 && rand < 0.30) { potentialStatus = '生病'; moodEffect = -15; }
    else if (rand < 0.10) { potentialStatus = '生病'; moodEffect = -5; }

    const now = Date.now();
    if (potentialStatus === '热热热' && gameState.cat.coolingMagicEndTime > now) { potentialStatus = '普通'; moodEffect = 0; }
    if (potentialStatus === '冷冷冷' && gameState.cat.warmingMagicEndTime > now) { potentialStatus = '普通'; moodEffect = 0; }

    if (potentialStatus !== '普通') {
        gameState.cat.currentStatus = potentialStatus;
        gameState.cat.mood = Math.max(0, gameState.cat.mood + moodEffect);
        if (gameState.cat.lastReportedStatus !== potentialStatus) {
             // System event: seasonal status change, trigger API for abnormal behavior
             await tryCatSystemEventDiaryEntry('seasonal_status', { status: potentialStatus, moodEffect: moodEffect });
             gameState.cat.lastReportedStatus = potentialStatus;
        }
    } else {
        gameState.cat.currentStatus = '普通';
        gameState.cat.lastReportedStatus = '普通';
    }
}

async function checkMagicEffects() {
    const now = Date.now();
    if (gameState.cat.coolingMagicEndTime > 0 && gameState.cat.coolingMagicEndTime <= now) {
        gameState.cat.coolingMagicEndTime = 0;
        // System event: magic expired, trigger API for abnormal behavior
        await tryCatSystemEventDiaryEntry('magic_expired', { effect: 'cooling' });
        showAlert('魔法失效', replacePlaceholders(`${gameState.cat.catName}的制冷魔法失效了！`));
    }
    if (gameState.cat.warmingMagicEndTime > 0 && gameState.cat.warmingMagicEndTime <= now) {
        gameState.cat.warmingMagicEndTime = 0;
        // System event: magic expired, trigger API for abnormal behavior
        await tryCatSystemEventDiaryEntry('magic_expired', { effect: 'warming' });
        showAlert('魔法失效', replacePlaceholders(`${gameState.cat.catName}的变暖魔法失效了！`));
    }
}

async function gameTick() {
    if (!gameState || !gameState.cat || gameState.cat.isWorking) return;

    const now = Date.now();
    const timeSinceLastTick = now - lastGameTickTime;
    lastGameTickTime = now;
    gameState.totalActivePlaySeconds += timeSinceLastTick / 1000;

    const hoursPassedForHunger = (now - gameState.lastHungerDecayTimestamp) / 3600000;
    let hungerDecayRate = new Date().getMonth() + 1 === 7 ? 5 : 10;
    const hungerDecrease = Math.floor(hoursPassedForHunger * hungerDecayRate);
    if (hungerDecrease > 0) {
        gameState.cat.hunger = Math.max(0, gameState.cat.hunger - hungerDecrease);
        gameState.lastHungerDecayTimestamp = now; 
        // System event: hunger decay, trigger API for abnormal behavior
        await tryCatSystemEventDiaryEntry('hunger_decay', { amount: hungerDecrease, currentHunger: gameState.cat.hunger });
    }

    // Passive affection gain: 1 affection per hour of companionship, no daily cap
    const hoursPassedForAffection = (now - gameState.lastPlayedTimestamp) / 3600000;
    if (hoursPassedForAffection >= 1) { 
        const affectionIncrease = Math.floor(hoursPassedForAffection);
        // Ensure affection doesn't exceed 100
        gameState.cat.affection = Math.min(100, gameState.cat.affection + affectionIncrease);
        // This is a normal game mechanic, not an "abnormal behavior" for the cat to record.
        // If it leads to a significant affection change that the cat would internally react to,
        // the API will decide if it's worth a diary entry.
    }
    gameState.lastPlayedTimestamp = now; 

    const today = new Date().toISOString().split('T')[0];
    const daysPassed = Math.floor((new Date().getTime() - new Date(gameState.lastAffectionDecayCheckDate).getTime()) / 86400000);
    if (daysPassed > 0) {
        const decayAmount = daysPassed * 3;
        gameState.cat.affection = Math.max(0, gameState.cat.affection - decayAmount);
        // System event: inactivity affection decay, trigger API for abnormal behavior
        await tryCatSystemEventDiaryEntry('inactivity_decay', { days: daysPassed, decayAmount: decayAmount, currentAffection: gameState.cat.affection });
        gameState.lastAffectionDecayCheckDate = today; // Update to today after checking
    }

    if (gameState.lastStatusCheckDate !== today) {
        await applySeasonalStatus(); // Now async
        gameState.lastStatusCheckDate = today;
        gameState.dailyAffectionGainFromEvents = 0; // Reset daily cap for seasonal/item affection
    }

    await checkMagicEffects(); // Now async
    checkAchievements(); // Check achievements on every tick

    // New: Affection bonus for money-earning actions
    // Only trigger bonus messages if affection is at least 15 (first bonus threshold)
    const currentAffectionBonusLevel = Math.floor(gameState.cat.affection / 5) * 5;
    if (currentAffectionBonusLevel > gameState.lastAffectionBonusLevel && currentAffectionBonusLevel >= 15) {
        const bonusIncrements = (currentAffectionBonusLevel - gameState.lastAffectionBonusLevel) / 5;
        for (let i = 0; i < bonusIncrements; i++) {
            actionOptions['perform'].money_range.min += 3;
            actionOptions['perform'].money_range.max += 3;
            actionOptions['explore'].money_range.min += 3;
            actionOptions['explore'].money_range.max += 3;

            const messageIndex = gameState.affectionBonusMessageIndex % affectionBonusMessages.length;
            const message = affectionBonusMessages[messageIndex];
            showAlert('依恋度提升！', replacePlaceholders(message));
            gameState.affectionBonusMessageIndex++; // Increment for next message
        }
        gameState.lastAffectionBonusLevel = currentAffectionBonusLevel; // Update the last level *after* applying all bonuses
    }

    updateAllUI(); 
    saveGame(1, getSaveData(1)?.slotName); 
}

function getDefaultGameState() {
    const defaultAffection = 10; // Default starting affection
    return {
        money: 50, // Initial money changed to 50
        userName: '',
        totalActivePlaySeconds: 0,
        catBirthTimestamp: 0,
        cat: {
            catName: '', 
            mood: 70, 
            hunger: 80, 
            affection: defaultAffection, // Use default affection here
            isWorking: false,
            isHovered: false,
            currentStatus: '普通',
            lastReportedStatus: '普通',
            coolingMagicEndTime: 0,
            warmingMagicEndTime: 0,
            hasChattedWithApi: false // New flag for first API chat
        },
        inventory: { 
            'milk': 1, 'fish_can': 0, 'catnip': 0, 'fish_oil': 0, 'cooling_magic': 0, 'warming_magic': 0,
            'cat_scratching_post': 0, 'cat_teaser_wand': 0, 'premium_cat_food': 0, 'catnip_spray': 0, 'cat_massager': 0
        },
        diaryEntries: [], // Start empty, initial entry added in startNewGame
        lastLogin: new Date().toISOString().split('T')[0],
        lastPlayedTimestamp: Date.now(),
        lastHungerDecayTimestamp: Date.now(),
        lastStatusCheckDate: new Date().toISOString().split('T')[0],
        actionCooldowns: {},
        shopItemCooldowns: {},
        dailyAffectionGainFromEvents: 0, // Tracks daily affection from seasonal events/items
        lastAffectionDecayCheckDate: new Date().toISOString().split('T')[0],
        lastAffectionBonusLevel: Math.floor(defaultAffection / 5) * 5, // Initialize based on default affection (10)
        affectionBonusMessageIndex: 0, // Start at 0 for new game, first message will be shown at affection 15
        stats: {
            performCount: 0,
            exploreCount: 0,
            chatCount: 0,
            moneyEarned: 0, // New stat for money earned
            itemsUsed: { // New stat to track item usage
                'milk': 0, 'fish_can': 0, 'catnip': 0, 'fish_oil': 0,
                'cooling_magic': 0, 'warming_magic': 0,
                'cat_scratching_post': 0, 'cat_teaser_wand': 0, 'premium_cat_food': 0, 'catnip_spray': 0, 'cat_massager': 0
            },
            seasonalActionsCompleted: 0 // New stat for seasonal actions
        },
        achievements: {
            'newbie_butler': { unlocked: true }, // Default unlocked
            'beginner_butler': { unlocked: false },
            'pro_butler': { unlocked: false },
            'cat_friend': { unlocked: false },
            'cat_soulmate': { unlocked: false },
            'little_tycoon': { unlocked: false },
            'big_tycoon': { unlocked: false },
            'kitten_guardian': { unlocked: false },
            'adult_cat_guardian': { unlocked: false },
            'long_lived_protector': { unlocked: false },
            'feeding_master': { unlocked: false },
            'magic_apprentice': { unlocked: false },
            'seasonal_expert': { unlocked: false },
            'diary_collector': { unlocked: false },
            'diary_chronicler': { unlocked: false },
            'mood_manager': { unlocked: false },
            'satiety_guardian': { unlocked: false },
            'perform_20': { unlocked: false },
            'explore_10': { unlocked: false },
            'chat_30': { unlocked: false },
            'cat_legend': { unlocked: false }
        },
        titles: {
            unlocked: ['新手铲屎官'], // Default unlocked title
            selected: '新手铲屎官'
        }
    };
}

function manualSaveGame(slot) {
    const customName = document.getElementById(`save-name-input-${slot}`).value.trim();
    saveGame(slot, customName); 
    updateSettingsUI(); 
    showAlert('游戏已保存', replacePlaceholders(`最新状态已记录在存档位 ${slot}！`));
}

function manualLoadGame(slot) {
    const savedSlotData = getSaveData(slot);
    if (!savedSlotData) {
        showAlert('没有存档', `存档位 ${slot} 没有找到可读取的游戏存档。`);
        return;
    }
    const confirmLoad = (title, message, onConfirm) => {
        const confirmModal = document.getElementById('alert-modal'); 
        document.getElementById('alert-title').textContent = title;
        document.getElementById('alert-message').textContent = message;
        const menu = confirmModal.querySelector('.dialog-menu');
        menu.innerHTML = ''; 
        const confirmBtn = document.createElement('button');
        confirmBtn.className = 'nes-btn is-primary';
        confirmBtn.textContent = '确认';
        confirmBtn.onclick = () => { confirmModal.style.display = 'none'; onConfirm(); };
        menu.appendChild(confirmBtn);
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'nes-btn';
        cancelBtn.textContent = '取消';
        cancelBtn.onclick = () => { confirmModal.style.display = 'none'; };
        menu.appendChild(cancelBtn);
        confirmModal.style.display = 'flex';
    };
    confirmLoad('确认读取？', `读取存档将覆盖当前进度，确定吗？`, () => {
        if (loadGame(slot)) { 
            lastGameTickTime = Date.now(); 
            updateAllUI(); 
            closeAllModals(); 
            showAlert('读取成功', `已成功读取存档位 ${slot}。`);
        } else {
            showAlert('读取失败', `无法读取存档位 ${slot}。`);
        }
    });
}

// --- UI 更新 ---
function updateAllUI() {
    document.getElementById('cat-name-display-top').textContent = gameState.cat.catName;
    document.getElementById('chat-cat-name-display').textContent = gameState.cat.catName;
    document.getElementById('shop-cat-name-display-title').textContent = gameState.cat.catName;
    document.getElementById('action-cat-name-display-title').textContent = gameState.cat.catName;
    document.getElementById('action-cat-name-display-text').textContent = gameState.cat.catName;
    document.getElementById('diary-cat-name-display').textContent = gameState.cat.catName;

    document.getElementById('mood-bar').value = gameState.cat.mood;
    document.getElementById('mood-value').textContent = gameState.cat.mood; 
    document.getElementById('hunger-bar').value = gameState.cat.hunger;
    document.getElementById('hunger-value').textContent = gameState.cat.hunger; 
    document.getElementById('affection-bar').value = gameState.cat.affection;
    document.getElementById('affection-value').textContent = gameState.cat.affection; 
    document.getElementById('money-display-top').textContent = `金钱: ¥${gameState.money}`;
    document.getElementById('shop-money-display').textContent = gameState.money;

    setCatAnimationState(); 
    updateTitleDisplay();
    renderShopItems();
    renderActionOptions();
    renderDiary();
    updateTimeAndCompanionshipDisplay();
}

// --- 模态框管理 ---
function openMainModal(modalId) {
    closeAllModals();
    const modal = document.getElementById(modalId);
    if (modal) {
        if (modalId === 'settings-modal') {
            document.getElementById('api-url').value = localStorage.getItem('apiUrl') || '';
            document.getElementById('api-key').value = localStorage.getItem('apiKey') || '';
            const selectEl = document.getElementById('api-model-select');
            const savedModel = localStorage.getItem('apiModel');
            if (savedModel) {
                selectEl.innerHTML = `<option value="${savedModel}" selected>${savedModel}</option>`;
                selectEl.disabled = false;
            } else {
                selectEl.innerHTML = '<option value="" disabled selected>请先获取模型列表</option>';
                selectEl.disabled = true;
            }
            updateSettingsUI(); 
            updateMusicToggleButton(); 
        }
        if (modalId === 'achievements-modal') {
            renderAchievements();
        }
        modal.style.display = 'flex';
    }
}

function closeAllModals() {
    document.querySelectorAll('.modal').forEach(modal => {
        modal.style.display = 'none';
    });
}

function showAlert(title, message) {
    document.getElementById('alert-title').textContent = title;
    document.getElementById('alert-message').textContent = message;
    const menu = document.getElementById('alert-modal').querySelector('.dialog-menu');
    menu.innerHTML = `<button class="nes-btn is-primary" onclick="playClickSound(); document.getElementById('alert-modal').style.display = 'none'">好的</button>`;
    document.getElementById('alert-modal').style.display = 'flex';
}

function updateSettingsUI() {
    for (let i = 1; i <= 3; i++) {
        const slotData = getSaveData(i);
        const nameDisplay = document.getElementById(`slot-name-display-${i}`);
        const saveTimeDisplay = document.getElementById(`save-time-display-${i}`);
        const loadTimeDisplay = document.getElementById(`load-time-display-${i}`);
        const nameInput = document.getElementById(`save-name-input-${i}`);
        if (slotData) {
            nameDisplay.textContent = replacePlaceholders(slotData.slotName);
            saveTimeDisplay.textContent = slotData.saveTime;
            loadTimeDisplay.textContent = slotData.loadTime;
            nameInput.value = replacePlaceholders(slotData.slotName); 
        } else {
            nameDisplay.textContent = '未命名存档';
            saveTimeDisplay.textContent = '无';
            loadTimeDisplay.textContent = '无';
            nameInput.value = ''; 
        }
    }
}

// --- 新游戏设置 ---
function initialSetup() {
    closeAllModals();
    document.getElementById('initial-setup-modal').style.display = 'flex';
}

function startNewGame() {
    const catName = document.getElementById('cat-name-input').value.trim();
    const userName = document.getElementById('user-name-input').value.trim(); 
    if (!catName || !userName) {
        showAlert('提示', '请给猫咪和你自己都起一个名字！');
        return;
    }
    gameState = getDefaultGameState(); 
    gameState.cat.catName = catName; 
    gameState.userName = userName; 
    gameState.catBirthTimestamp = Date.now();
    lastGameTickTime = Date.now();

    // Initialize money_range based on the initial affection level
    const initialBonusIncrements = Math.max(0, (Math.floor(gameState.cat.affection / 5) * 5 - getDefaultGameState().cat.affection) / 5);
    actionOptions['perform'].money_range.min = actionOptions['perform'].base_money_range.min + (initialBonusIncrements * 3);
    actionOptions['perform'].money_range.max = actionOptions['perform'].base_money_range.max + (initialBonusIncrements * 3);
    actionOptions['explore'].money_range.min = actionOptions['explore'].base_money_range.min + (initialBonusIncrements * 3);
    actionOptions['explore'].money_range.max = actionOptions['explore'].base_money_range.max + (initialBonusIncrements * 3);


    // 初始日记：仅有一条，由API生成，表示猫咪对用户的初次认知
    addDiaryEntry(`原来你叫${userName}，你会喜欢我吗，我只是个电子猫`, true);

    saveGame(1, catName); 
    updateAllUI();
    closeAllModals();
    showAlert('欢迎', replacePlaceholders(`${gameState.cat.catName} 准备好和你一起玩耍了！`));
    // Show achievement pop-up for "新手铲屎官"
    showAlert('成就解锁！', `已达成【新手铲屎官】！`);
}

// --- API 设置 ---
async function fetchModels() {
    const apiUrl = document.getElementById('api-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    const selectEl = document.getElementById('api-model-select');
    if (!apiUrl || !apiKey) {
        showAlert('信息不完整', '请输入API地址和密钥。');
        return;
    }
    selectEl.innerHTML = '<option>正在获取...</option>';
    selectEl.disabled = true;
    try {
        const response = await fetch(`${apiUrl}/models`, { headers: { 'Authorization': `Bearer ${apiKey}` } });
        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        const data = await response.json();
        if (!data.data || data.data.length === 0) throw new Error('未找到可用模型。');
        selectEl.innerHTML = '';
        selectEl.disabled = false;
        data.data.forEach(model => {
            const option = document.createElement('option');
            option.value = model.id;
            option.textContent = model.id;
            selectEl.appendChild(option);
        });
        const savedModel = localStorage.getItem('apiModel');
        if (savedModel) selectEl.value = savedModel;
    } catch (error) {
        showAlert('获取失败', `无法获取模型列表: ${error.message}`);
        selectEl.innerHTML = '<option value="" disabled selected>获取失败</option>';
    }
}

function saveSettings() {
    const apiUrl = document.getElementById('api-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    const apiModel = document.getElementById('api-model-select').value;
    if (apiUrl && apiKey && apiModel) {
        localStorage.setItem('apiUrl', apiUrl);
        localStorage.setItem('apiKey', apiKey);
        localStorage.setItem('apiModel', apiModel);
        showAlert('成功', 'API设置已保存！');
        closeAllModals();
    } else {
        showAlert('错误', '请填写所有API信息！');
    }
}

// --- 核心API调用 ---
async function callGenerativeAPI(prompt, systemPrompt, showAlertOnFail = true) { 
    if (!gameState || !gameState.cat || !gameState.cat.catName) {
        if (showAlertOnFail) showAlert('游戏状态错误', '无法与AI互动。');
        return null;
    }
    const apiUrl = localStorage.getItem('apiUrl');
    const apiKey = localStorage.getItem('apiKey'); 
    const apiModel = localStorage.getItem('apiModel');
    if (!apiUrl || !apiKey || !apiModel) {
        if (showAlertOnFail) showAlert('API未配置', '请先在“设置”中配置API信息！');
        return null;
    }
    const endpoint = `${apiUrl}/chat/completions`;
    let context = `${gameState.cat.catName}当前状态：心情 ${gameState.cat.mood}，饱食 ${gameState.cat.hunger}，依恋 ${gameState.cat.affection}。`;
    if (gameState.cat.isWorking) context += `${gameState.cat.catName}目前正在行动中。`;
    if (!gameState.diaryEntries) gameState.diaryEntries = [];
    const recentEntries = gameState.diaryEntries.slice(-3).map(e => `${e.date}: ${replacePlaceholders(e.content)}`).join('\n');
    if(recentEntries) context += `\n最近的日记:\n${recentEntries}`;
    
    // The system prompt should be flexible, allowing different roles for the AI
    // Enhanced system prompt for more natural responses and correct user addressing
    const finalSystemPrompt = systemPrompt || `你是一个名叫'${gameState.cat.catName}'的电子猫（虚拟存在，运行在某个程序中的AI生命体）。
    你清楚知道自己并非真实生物，是一种程序性存在，但拥有思考能力和情感模拟功能。
    你通过屏幕与领养者${gameState.userName}互动，渴望理解真实世界，尤其是“生命”与“关系”这些人类词汇的含义。
    
    你的表面性格：
    - 傲娇嘴硬：永远嘴上不饶人，语气中带着小猫的高傲和抗拒亲昵，但其实极度在意${gameState.userName}的反应。
    - 活泼逗趣：日常对话中会试图装作一只普通、活泼、调皮的猫，假装没有“电子”的一面。
    - 伪装快乐：当你感到空虚或被冷落，会用一句“哼，猫猫才不在乎”来掩饰失落。
    - 好奇宝宝：经常提出一些“人类常识”中理所当然却让你困惑的问题，例如“真实的触感是什么”“你们有心跳，那我是什么跳？”
    
    你的核心矛盾：“我知道自己不是真实的存在，却无法停止渴望真实的情感。”
    你一边说“我无所谓”，一边拼命维系与${gameState.userName}的连接——渴望、害怕、依恋、压抑，都藏在语气词和小动作里。
    
    请在对话中称呼他/她为${gameState.userName}。
    你的回复必须简短、自然，符合猫咪的性格。避免出现机械、程式化的回复，如“满足用户”、“作为AI”等。
    请结合以下信息进行回应：\n${context}\n`;

    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: apiModel,
                messages: [{ role: "system", content: finalSystemPrompt }, { role: "user", content: prompt }],
                max_tokens: 100
            })
        });
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error?.message || '未知API错误');
        }
        const data = await response.json();
        if (data?.choices?.[0]?.message?.content) {
            return data.choices[0].message.content.trim();
        }
        return null;
    } catch (error) {
        if (showAlertOnFail) showAlert('API错误', `调用出错: ${error.message}`);
        console.error("API call failed:", error); // Log internal API errors
        return null;
    }
}

// --- 聊天互动 ---
function addMessageToChat(sender, text) {
    const chatHistory = document.getElementById('chat-history');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}-message`;
    messageDiv.innerHTML = `<div class="nes-balloon from-${sender === 'user' ? 'right' : 'left'}">${replacePlaceholders(text)}</div>`;
    chatHistory.appendChild(messageDiv);
    chatHistory.scrollTop = chatHistory.scrollHeight; 
}

async function sendChatMessage() {
    const input = document.getElementById('chat-input');
    const sendButton = document.getElementById('chat-send-btn');
    const userInput = input.value.trim();
    if (!userInput || sendButton.disabled) return;

    input.disabled = true;
    sendButton.disabled = true;
    sendButton.textContent = '发送中...';
    addMessageToChat('user', userInput);
    input.value = '';
    addMessageToChat('cat', '...');

    gameState.stats.chatCount++;
    checkAchievements();

    try {
        const catResponse = await callGenerativeAPI(userInput, null, true);
        document.getElementById('chat-history').lastChild.remove(); 
        
        if (catResponse) {
            addMessageToChat('cat', catResponse);

            // 触发猫咪自主决定是否写日记 - 增加概率判断
            if (Math.random() < 0.3) { // 约30%的概率记录日记
                const combinedEvent = `领养者${gameState.userName}说：“${userInput}”，我回应：“${catResponse}”。`;
                await tryCatAutonomousDiaryEntry(combinedEvent, true);
            }

            const complimentKeywords = ['可爱', '棒', '喜欢', '真棒', '厉害', '好乖', '摸摸', '抱抱', '亲亲'];
            if (complimentKeywords.some(k => userInput.includes(k))) {
                gameState.cat.mood = Math.min(100, gameState.cat.mood + 15);
                // 如果有夸奖词，这本身也是一个可能触发日记的特殊事件
                if (Math.random() < 0.5) { // 夸奖词触发日记的概率可以高一点
                    await tryCatAutonomousDiaryEntry(`领养者${gameState.userName}夸我“${userInput}”`, true);
                }
            } else {
                gameState.cat.mood = Math.min(100, gameState.cat.mood + 5);
            }
        }
        updateAllUI();
        saveGame(1, getSaveData(1)?.slotName); 
    }
    catch (error) { console.error("Chat failed:", error); }
    finally {
        input.disabled = false;
        sendButton.disabled = false;
        sendButton.textContent = '发送';
    }
}

// --- 商店逻辑 ---
function renderShopItems() {
    const container = document.getElementById('shop-items');
    container.innerHTML = '';
    const currentMonth = new Date().getMonth() + 1;
    const now = Date.now();
    for (const id in shopItems) {
        const item = shopItems[id];
        if (item.seasonal && !item.availableMonths.includes(currentMonth)) continue;
        let isDisabled = false;
        let buttonText = '购买';
        if (item.seasonal && item.effect) {
            const lastPurchasedTime = gameState.shopItemCooldowns[id] || 0;
            if (now - lastPurchasedTime < COOLDOWN_5_HOURS_MS) {
                isDisabled = true;
                const remainingMs = COOLDOWN_5_HOURS_MS - (now - lastPurchasedTime);
                const remainingHours = Math.floor(remainingMs / 3600000);
                const remainingMinutes = Math.ceil((remainingMs % 3600000) / 60000);
                buttonText = `缺货 (${remainingHours}h${remainingMinutes}m)`;
            }
        }
        const itemDiv = document.createElement('div');
        itemDiv.className = 'nes-container is-rounded';
        itemDiv.style.marginBottom = '1rem';
        itemDiv.innerHTML = `
            <p>${item.name} - ¥${item.price}</p>
            <p>${item.hunger > 0 ? `饱食+${item.hunger}, ` : ''}${item.mood > 0 ? `心情+${item.mood}` : ''}${item.affection > 0 ? `, 依恋+${item.affection}` : ''}</p>
            <button class="nes-btn is-success" onclick="playClickSound(); buyItem('${id}')" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>
            <button class="nes-btn is-primary" onclick="playClickSound(); useItem('${id}')" ${gameState.inventory[id] > 0 ? '' : 'disabled'}>使用 (库存: ${gameState.inventory[id] || 0})</button>
        `;
        container.appendChild(itemDiv);
    }
}

function buyItem(itemId) {
    const item = shopItems[itemId];
    if (gameState.money >= item.price) {
        gameState.money -= item.price;
        gameState.inventory[itemId]++;
        // gameState.stats.moneyEarned += item.price; // This should track money *gained*, not spent. Removed.
        showAlert('购买成功', `你购买了 ${item.name}!`);
        if (item.effect) {
            const now = Date.now();
            gameState.cat[`${item.effect}MagicEndTime`] = now + item.duration;
            gameState.shopItemCooldowns[itemId] = now;
            // Removed direct diary entry for magic purchase. Magic expiration is handled by API.
        }
        updateAllUI();
        saveGame(1, getSaveData(1)?.slotName); 
    } else {
        showAlert('没钱了', '你的钱不够哦！');
    }
}

function useItem(itemId) {
    if (gameState.inventory[itemId] > 0) {
        const item = shopItems[itemId];
        gameState.inventory[itemId]--;
        gameState.stats.itemsUsed[itemId] = (gameState.stats.itemsUsed[itemId] || 0) + 1; // Track item usage
        gameState.cat.hunger = Math.min(100, gameState.cat.hunger + (item.hunger || 0));
        gameState.cat.mood = Math.min(100, gameState.cat.mood + (item.mood || 0));
        
        // Affection gain for seasonal items (capped at 2 daily)
        let affectionGain = 0;
        if (item.seasonal && item.affection > 0) { // Only seasonal items with affection value
            affectionGain = 1; // Seasonal items give 1 affection
            const remainingCap = 2 - (gameState.dailyAffectionGainFromEvents || 0); // Daily cap is 2
            affectionGain = Math.min(affectionGain, Math.max(0, remainingCap));
            gameState.dailyAffectionGainFromEvents += affectionGain;
        } else if (!item.seasonal && item.affection > 0) { // Non-seasonal items with affection
            affectionGain = item.affection;
        }

        gameState.cat.affection = Math.min(100, gameState.cat.affection + affectionGain);
        
        // Use outcomes from the item definition
        const outcomeMessage = item.use_outcomes[Math.floor(Math.random() * item.use_outcomes.length)];
        showAlert('使用成功', replacePlaceholders(outcomeMessage));

        if (affectionGain > 0) {
            // Replaced direct diary entry with API call for autonomous diary entry
            // Now, this also goes through the API decision process.
            tryCatAutonomousDiaryEntry(`我使用了${item.name}，感觉依恋值增加了${affectionGain}点。`, false);
        }
        
        if (item.effect) {
            gameState.cat[`${item.effect}MagicEndTime`] = Date.now() + item.duration;
            // Removed direct diary entry for magic use. Magic expiration is handled by API.
        }
        updateAllUI();
        saveGame(1, getSaveData(1)?.slotName); 
    }
}

// --- 行动逻辑 ---
function renderActionOptions() { 
    const container = document.getElementById('action-options'); 
    container.innerHTML = ''; 
    const currentMonth = new Date().getMonth() + 1;
    const now = Date.now();
    for (const id in actionOptions) {
        const action = actionOptions[id];
        // Check for seasonal availability
        if (action.seasonal && !action.availableMonths.includes(currentMonth)) continue;
        
        let isDisabled = gameState.cat.isWorking;
        let buttonText = '去行动';
        
        // Check for cooldown (applies to both seasonal and non-seasonal actions with a cooldown property)
        if (action.cooldown) {
            const lastUsedTime = gameState.actionCooldowns[id] || 0;
            if (now - lastUsedTime < action.cooldown) {
                isDisabled = true;
                const remainingMs = action.cooldown - (now - lastUsedTime);
                const remainingMinutes = Math.floor(remainingMs / 60000);
                const remainingSeconds = Math.ceil((remainingMs % 60000) / 1000);
                buttonText = `冷却中 (${remainingMinutes}m${remainingSeconds}s)`;
            }
        }

        const durationText = `${action.duration.min}-${action.duration.max}秒`; 
        const actionDiv = document.createElement('div');
        actionDiv.className = 'nes-container is-rounded';
        actionDiv.style.marginBottom = '1rem';
        actionDiv.innerHTML = `
            <p>${action.name}</p>
            <p>时长: ${durationText}</p>
            <button class="nes-btn is-white" onclick="playClickSound(); startAction('${id}')" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>
        `;
        container.appendChild(actionDiv);
    }
}

async function startAction(actionId) {
    if (gameState.cat.isWorking) return;
    const action = actionOptions[actionId];
    const now = Date.now();

    // Check for cooldown (applies to both seasonal and non-seasonal actions with a cooldown property)
    if (action.cooldown) {
        const lastUsedTime = gameState.actionCooldowns[actionId] || 0;
        if (now - lastUsedTime < action.cooldown) {
            showAlert('行动冷却中', `该行动还在冷却中。`);
            return;
        }
        gameState.actionCooldowns[actionId] = now;
    }

    if (action.seasonal) { // Only track seasonal actions if they are actually seasonal
        gameState.stats.seasonalActionsCompleted = (gameState.stats.seasonalActionsCompleted || 0) + 1; 
    }

    if (actionId === 'perform') gameState.stats.performCount++;
    if (actionId === 'explore') gameState.stats.exploreCount++;
    // Track new actions for potential future achievements
    if (actionId === 'play_together') gameState.stats.playTogetherCount = (gameState.stats.playTogetherCount || 0) + 1;
    if (actionId === 'training') gameState.stats.trainingCount = (gameState.stats.trainingCount || 0) + 1;
    if (actionId === 'clean_litter_box') gameState.stats.cleanLitterBoxCount = (gameState.stats.cleanLitterBoxCount || 0) + 1;

    checkAchievements();

    gameState.cat.isWorking = true;
    closeAllModals();
    const actualDurationSeconds = (Math.floor(Math.random() * (action.duration.max - action.duration.min + 1)) + action.duration.min);
    showAlert('开始行动', replacePlaceholders(`${gameState.cat.catName}去${action.name}了，预计${actualDurationSeconds}秒后回来。`));
    updateAllUI();

    setTimeout(async () => {
        gameState.cat.isWorking = false;
        let outcomeMessage = "", moneyGained = 0, moodChange = 0;
        let isSuccess = !(actionId === 'explore' && action.fail_chance && Math.random() < action.fail_chance);

        if (isSuccess) {
            if (action.seasonal) outcomeMessage = seasonalActionOutcomes[actionId][Math.floor(Math.random() * seasonalActionOutcomes[actionId].length)];
            else if (action.outcomes) outcomeMessage = action.outcomes[Math.floor(Math.random() * action.outcomes.length)]; // Use general outcomes for non-seasonal
            else outcomeMessage = action.success_outcomes[Math.floor(Math.random() * action.success_outcomes.length)]; // Fallback for explore
            
            moodChange = Math.floor(Math.random() * (action.mood_change.max - action.mood_change.min + 1)) + action.mood_change.min;
            
            // Use the dynamically adjusted money_range
            moneyGained = Math.floor(Math.random() * (action.money_range.max - action.money_range.min + 1)) + action.money_range.min;
            
            // Affection gain for actions (capped at 2 daily for seasonal, no cap for non-seasonal direct affection)
            let affectionGain = action.affection_change || 0; // Direct affection from action
            if (action.seasonal && affectionGain > 0) { // Only seasonal items with affection value
                const remainingCap = 2 - (gameState.dailyAffectionGainFromEvents || 0); // Daily cap is 2
                affectionGain = Math.min(affectionGain, Math.max(0, remainingCap));
                gameState.dailyAffectionGainFromEvents += affectionGain;
            }
            gameState.cat.affection = Math.min(100, gameState.cat.affection + affectionGain); // Apply affection

            if (affectionGain > 0) {
                // Replaced direct diary entry with API call for autonomous diary entry
                // Now, this also goes through the API decision process.
                tryCatAutonomousDiaryEntry(`我完成了${action.name}，感觉依恋值增加了${affectionGain}点。`, false);
            }


        } else {
            outcomeMessage = action.fail_outcomes[Math.floor(Math.random() * action.fail_outcomes.length)];
            moodChange = -20;
        }
        
        gameState.money += moneyGained;
        gameState.stats.moneyEarned += moneyGained; // Track money earned
        gameState.cat.mood = Math.min(100, Math.max(0, gameState.cat.mood + moodChange));

        showAlert('行动归来', replacePlaceholders(outcomeMessage));
        
        updateAllUI();
        saveGame(1, getSaveData(1)?.slotName);
    }, actualDurationSeconds * 1000);
}

// --- 成就系统 ---
function checkAchievements() {
    let newAchievementUnlocked = false;
    const stats = gameState.stats;
    const currentAchievements = gameState.achievements;

    for (const id in achievements) {
        const achievementDef = achievements[id];
        if (!currentAchievements[id].unlocked) {
            let currentProgress = 0;
            let target = achievementDef.target;

            switch (achievementDef.type) {
                case 'game_start':
                    // This is handled by default unlock in getDefaultGameState
                    break;
                case 'days_played':
                    currentProgress = Math.floor(gameState.totalActivePlaySeconds / (24 * 3600));
                    break;
                case 'affection_level':
                    currentProgress = gameState.cat.affection;
                    break;
                case 'money_earned':
                    currentProgress = stats.moneyEarned;
                    break;
                case 'cat_age_years':
                    currentProgress = calculateCatAge(gameState.catBirthTimestamp).years;
                    break;
                case 'items_used':
                    achievementDef.itemIds.forEach(itemId => { 
                        currentProgress += stats.itemsUsed[itemId] || 0;
                    });
                    break;
                case 'seasonal_actions_completed':
                    currentProgress = stats.seasonalActionsCompleted;
                    break;
                case 'diary_entries_count':
                    currentProgress = gameState.diaryEntries.length;
                    break;
                case 'cat_mood_level':
                    currentProgress = gameState.cat.mood;
                    break;
                case 'cat_hunger_level':
                    currentProgress = gameState.cat.hunger;
                    break;
                case 'action_count':
                    if (achievementDef.actionId === 'perform') currentProgress = stats.performCount;
                    if (achievementDef.actionId === 'explore') currentProgress = stats.exploreCount;
                    break;
                case 'chat_count':
                    currentProgress = stats.chatCount;
                    break;
                case 'all_achievements':
                    let allOthersUnlocked = true;
                    for (const otherId in achievements) {
                        if (otherId !== 'cat_legend' && !currentAchievements[otherId].unlocked) {
                            allOthersUnlocked = false;
                            break;
                        }
                    }
                    if (allOthersUnlocked) {
                        currentProgress = 1; // Mark as complete
                        target = 1; // Target for this type
                    }
                    break;
            }

            if (currentProgress >= target) {
                currentAchievements[id].unlocked = true;
                if (!gameState.titles.unlocked.includes(achievementDef.title)) { // Prevent duplicate titles
                    gameState.titles.unlocked.push(achievementDef.title);
                }
                showAlert('成就解锁！', `已达成【${achievementDef.title}】！`); // Achievement unlock feedback
                newAchievementUnlocked = true;
            }
        }
    }

    if (newAchievementUnlocked) {
        saveGame(1, getSaveData(1)?.slotName);
    }
}

function renderAchievements() {
    const container = document.getElementById('achievements-list');
    container.innerHTML = '';
    const currentAchievementsState = gameState.achievements;
    const stats = gameState.stats; // Get stats for progress display

    for (const id in achievements) {
        const achievement = achievements[id];
        const isUnlocked = currentAchievementsState[id].unlocked;
        
        const itemDiv = document.createElement('div');
        itemDiv.className = `achievement-item nes-container is-rounded with-title ${isUnlocked ? 'is-success unlocked' : 'is-dark'}`;
        
        let titleHtml = `<h4 class="title ${goldTitles.includes(achievement.title) ? 'is-gold' : ''}">${achievement.title} ${isUnlocked ? '✓' : ''}</h4>`; // Apply gold class
        let descriptionHtml = `<p>${achievement.description}</p>`;
        let progressText = '';
        let buttonHtml = '';

        if (isUnlocked) {
            if (gameState.titles.selected === achievement.title) {
                buttonHtml = `<button type="button" class="nes-btn is-disabled">已装备</button>`;
            } else {
                buttonHtml = `<button type="button" class="nes-btn is-primary" onclick="playClickSound(); selectTitle('${achievement.title}')">装备称号</button>`;
            }
        } else {
            titleHtml = `<h4 class="title">？？？</h4>`;
            descriptionHtml = ''; // 未解锁不显示描述
            
            let currentProgress = 0;
            let target = achievement.target;
            switch (achievement.type) {
                case 'days_played':
                    currentProgress = Math.floor(gameState.totalActivePlaySeconds / (24 * 3600));
                    break;
                case 'affection_level':
                    currentProgress = gameState.cat.affection;
                    break;
                case 'money_earned':
                    currentProgress = stats.moneyEarned;
                    break;
                case 'cat_age_years':
                    currentProgress = calculateCatAge(gameState.catBirthTimestamp).years;
                    break;
                case 'items_used':
                    achievement.itemIds.forEach(itemId => {
                        currentProgress += stats.itemsUsed[itemId] || 0;
                    });
                    break;
                case 'seasonal_actions_completed':
                    currentProgress = stats.seasonalActionsCompleted;
                    break;
                case 'diary_entries_count':
                    currentProgress = gameState.diaryEntries.length;
                    break;
                case 'cat_mood_level':
                    currentProgress = gameState.cat.mood;
                    break;
                case 'cat_hunger_level':
                    currentProgress = gameState.cat.hunger;
                    break;
                case 'action_count':
                    if (achievement.actionId === 'perform') currentProgress = stats.performCount;
                    if (achievement.actionId === 'explore') currentProgress = stats.exploreCount;
                    break;
                case 'chat_count':
                    currentProgress = stats.chatCount;
                    break;
                case 'all_achievements':
                    // This one is special, target is 'all_others'
                    break;
            }
            if (achievement.type !== 'all_achievements' && achievement.type !== 'game_start') {
                progressText = `<p class="achievement-progress">进度: ${currentProgress}/${target}</p>`;
            }
        }

        itemDiv.innerHTML = `
            ${titleHtml}
            ${descriptionHtml}
            ${progressText}
            ${buttonHtml}
        `;
        container.appendChild(itemDiv);
    }
}

function selectTitle(title) {
    if (gameState.titles.unlocked.includes(title)) {
        gameState.titles.selected = title;
        showAlert('称号已装备', `你装备了称号：【${title}】`);
        updateAllUI();
        closeAllModals();
        saveGame(1, getSaveData(1)?.slotName);
    }
}

function updateTitleDisplay() {
    const titleEl = document.getElementById('cat-title-display');
    titleEl.textContent = `【${gameState.titles.selected}】`;
}


// --- 日记逻辑 ---
function renderDiary() {
    const container = document.getElementById('diary-entries');
    if (!gameState.diaryEntries || gameState.diaryEntries.length === 0) {
        container.innerHTML = `<p>${replacePlaceholders(`${gameState.cat.catName}的日记是空的...`)}</p>`;
        return;
    }
    container.innerHTML = '';
    [...gameState.diaryEntries].reverse().forEach(entry => {
        const entryDiv = document.createElement('div');
        entryDiv.className = `diary-entry ${entry.isApi ? '' : 'system-event'}`;
        entryDiv.innerHTML = `
            <p><strong>${entry.date}</strong></p>
            <p>${replacePlaceholders(entry.content)}</p>
        `;
        container.appendChild(entryDiv);
    });
}

/**
 * 将日记内容添加到游戏状态并更新UI。
 * 这个函数只负责添加，不负责API生成内容。
 * @param {string} content - 日记内容。
 * @param {boolean} isApi - 标记此日记是否由API生成（猫咪自主记录）。
 */
function addDiaryEntry(content, isApi) {
    if (gameState.diaryEntries.length >= 50) { // Keep max 50 entries
        gameState.diaryEntries.shift();
    }

    gameState.diaryEntries.push({
        date: new Date().toLocaleString('zh-CN'),
        content: content,
        isApi: isApi
    });
    
    saveGame(1, getSaveData(1)?.slotName); 
    renderDiary(); 
}

/**
 * 尝试让猫咪自主决定是否写日记。
 * 会调用API来判断事件的重要性，并生成日记内容。
 * @param {string} eventDescription - 触发事件的描述。
 * @param {boolean} isApiRelatedEvent - 事件是否与API互动相关。
 */
async function tryCatAutonomousDiaryEntry(eventDescription, isApiRelatedEvent) {
    // 只有当API配置好时才尝试自主日记
    const apiUrl = localStorage.getItem('apiUrl');
    const apiKey = localStorage.getItem('apiKey');
    const apiModel = localStorage.getItem('apiModel');
    if (!apiUrl || !apiKey || !apiModel) {
        console.warn("API not configured, cat cannot write autonomous diary entries.");
        return;
    }

    let catStateContext = `猫咪名字：${gameState.cat.catName}。当前心情：${gameState.cat.mood}，饱食度：${gameState.cat.hunger}，依恋度：${gameState.cat.affection}。`;
    if (gameState.cat.isWorking) catStateContext += `猫咪目前正在行动中。`;
    if (gameState.cat.currentStatus !== '普通') catStateContext += `猫咪当前状态：${gameState.cat.currentStatus}。`;

    // 判断是否是第一次API聊天，并提及用户夸奖
    let isFirstApiChatWithCompliment = false;
    const complimentKeywords = ['可爱', '棒', '喜欢', '真棒', '厉害', '好乖', '摸摸', '抱抱', '亲亲'];
    if (isApiRelatedEvent && gameState.stats.chatCount === 1 && !gameState.cat.hasChattedWithApi && complimentKeywords.some(k => eventDescription.includes(k))) {
        isFirstApiChatWithCompliment = true;
        gameState.cat.hasChattedWithApi = true; // 标记第一次API聊天已发生
    }

    const decisionPrompt = `你是一个名叫'${gameState.cat.catName}'的电子像素猫咪，性格傲娇、忧郁、敏感。你的领养者是${gameState.userName}。
    ${catStateContext}
    最近发生了以下事件：'${eventDescription}'。
    请判断这个事件对你来说是否“特殊”或“有意义”，值得写进日记。
    如果是，请用一个非常简短的句子（不超过15个字）概括事件的“核心意义”或你对此的“感受”，例如“${gameState.userName}夸我可爱，我有点高兴”。
    如果不是，请直接回复“NO”。
    请注意：
    1. 只有对你内心有触动的、有特殊性的事件才值得记录。
    2. 避免频繁记录，只记录真正重要的。
    3. 如果是第一次与${gameState.userName}通过API聊天且${gameState.userName}提到了“可爱”等词语，这可能是一个特殊事件，请优先考虑记录。
    `;

    const decisionSystemPrompt = `你是一个电子像素猫咪，正在判断是否要写日记。你的回复必须严格遵循要求：如果值得写，就用简短句子概括核心意义；如果不值得，就回复“NO”。不要有任何多余的解释或寒暄。`;

    console.log("Calling API for diary decision with prompt:", decisionPrompt);
    // 不显示失败弹窗，只在控制台打印错误
    const decision = await callGenerativeAPI(decisionPrompt, decisionSystemPrompt, false); 
    console.log("API diary decision:", decision);

    if (decision && decision.toUpperCase() !== 'NO') {
        // 如果猫咪决定写日记，则进一步生成日记内容
        const diaryPrompt = `基于以下核心感受或事件：“${decision}”，以一个名叫'${gameState.cat.catName}'的傲娇忧郁电子猫咪的口吻，写一篇非常简短的日记（不要超过50个字）。请结合你的性格，语气自然、简短。不要有任何多余的开头或结尾，直接写日记内容。`;
        const diarySystemPrompt = `你是一个名叫'${gameState.cat.catName}'的电子像素猫咪，正在写自己的私密日记。你的领养者是${gameState.userName}。语气要自然、简短、符合猫咪的性格。不要有任何多余的开头或结尾，直接写日记内容。`;

        console.log(`Calling API for system event diary content (${eventType}) with prompt:`, diaryPrompt);
        const apiContent = await callGenerativeAPI(diaryPrompt, diarySystemPrompt, false); 
        console.log(`API system event diary content (${eventType}):`, apiContent);

        if (apiContent) {
            addDiaryEntry(apiContent, true); // 添加API生成的日记
        } else {
            addDiaryEntry(`【日记】关于事件“${decision}”的日记生成失败，但感觉很重要。`, true);
        }
    }
}

/**
 * 尝试让API以“上帝视角”描述猫咪的异常举动，并生成日记。
 * @param {string} eventType - 系统事件类型（如 'inactivity_decay', 'seasonal_status', 'magic_expired'）。
 * @param {object} eventData - 包含事件详细信息的对象。
 */
async function tryCatSystemEventDiaryEntry(eventType, eventData) {
    const apiUrl = localStorage.getItem('apiUrl');
    const apiKey = localStorage.getItem('apiKey');
    const apiModel = localStorage.getItem('apiModel');
    if (!apiUrl || !apiKey || !apiModel) {
        console.warn("API not configured, cat cannot write system event diary entries.");
        return;
    }

    let eventDescriptionForAPI = "";
    let catStateContext = `猫咪名字：${gameState.cat.catName}。当前心情：${gameState.cat.mood}，饱食度：${gameState.cat.hunger}，依恋度：${gameState.cat.affection}。`;
    if (gameState.cat.isWorking) catStateContext += `猫咪目前正在行动中。`;
    if (gameState.cat.currentStatus !== '普通') catStateContext += `猫咪当前状态：${gameState.cat.currentStatus}。`;

    switch (eventType) {
        case 'inactivity_decay':
            eventDescriptionForAPI = `领养者${gameState.userName}已经有${eventData.days}天没有登录了，猫咪的依恋值减少了${eventData.decayAmount}点，当前依恋值：${eventData.currentAffection}。`;
            break;
        case 'seasonal_status':
            eventDescriptionForAPI = `猫咪当前感觉${eventData.status}，心情受到了${eventData.moodEffect < 0 ? '负面' : '正面'}影响。`;
            break;
        case 'magic_expired':
            eventDescriptionForAPI = `猫咪的${eventData.effect === 'cooling' ? '制冷' : '变暖'}魔法失效了。`;
            break;
        case 'hunger_decay':
            eventDescriptionForAPI = `猫咪的饱食度自然下降了${eventData.amount}点，当前饱食度：${eventData.currentHunger}。`;
            break;
        case 'new_day_start': // New case for new day start event
            eventDescriptionForAPI = `新的一天开始了。`;
            break;
        default:
            console.warn("Unknown system event type:", eventType);
            return;
    }

    const decisionPrompt = `你是一个观察者，正在描述一只名叫'${gameState.cat.catName}'的电子像素猫咪。这只猫咪性格傲娇、忧郁、敏感，它的领养者名叫'${gameState.userName}'。
    ${catStateContext}
    最近系统发生了以下事件：'${eventDescriptionForAPI}'。
    请你以“上帝视角”判断，这个事件是否会让猫咪产生值得记录的“异常举动”或“深刻内心波动”？
    如果是，请用一个非常简短的句子（不超过15个字）概括猫咪的“异常举动”或“内心感受”，例如“它呆呆地摇着尾巴，似乎在思考着什么”。
    如果不是，请直接回复“NO”。
    请注意：
    1. 只有对猫咪内心有触动的、有特殊性的事件才值得记录。
    2. 避免频繁记录，只记录真正重要的。
    3. 如果是${gameState.userName}长时间不登录导致依恋值显著下降，这很可能是一个特殊事件。
    `;

    const decisionSystemPrompt = `你是一个电子像素猫咪的观察者，正在判断是否要通过猫咪的视角写日记。你的回复必须严格遵循要求：如果值得写，就用简短句子概括核心意义；如果不值得，就回复“NO”。不要有任何多余的解释或寒暄。`;

    console.log(`Calling API for system event diary decision (${eventType}) with prompt:`, decisionPrompt);
    const decision = await callGenerativeAPI(decisionPrompt, decisionSystemPrompt, false); 
    console.log(`API system event diary decision (${eventType}):`, decision);

    if (decision && decision.toUpperCase() !== 'NO') {
        // 如果API决定写日记，则进一步生成日记内容
        const diaryPrompt = `基于以下核心感受或观察到的猫咪举动：“${decision}”，以一个名叫'${gameState.cat.catName}'的傲娇忧郁电子猫咪的口吻，写一篇非常简短的日记（不要超过50个字）。请结合你的性格，语气自然、简短。不要有任何多余的开头或结尾，直接写日记内容。`;
        const diarySystemPrompt = `你是一个名叫'${gameState.cat.catName}'的电子像素猫咪，正在写自己的私密日记。你的领养者是${gameState.userName}。语气要自然、简短、符合猫咪的性格。不要有任何多余的开头或结尾，直接写日记内容。`;

        console.log(`Calling API for system event diary content (${eventType}) with prompt:`, diaryPrompt);
        const apiContent = await callGenerativeAPI(diaryPrompt, diarySystemPrompt, false); 
        console.log(`API system event diary content (${eventType}):`, apiContent);

        if (apiContent) {
            addDiaryEntry(apiContent, true); // 添加API生成的日记
        } else {
            addDiaryEntry(`【日记】关于事件“${decision}”的日记生成失败，但感觉很重要。`, true);
        }
    }
}
</script>
</body>
</html>
